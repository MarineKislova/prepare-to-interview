/* Общий список вопросов по Javascript */
const questionsJS = [
  {
    id: 1,
    question: "Какие типы данных (примитивные типы данных) есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<ul> <li><span>Number</span> – число. Тип Number в JavaScript может хранить как целые числа, так и числа с плавающей точкой.</li> <li><span>BigInt</span> – используется для представления целых чисел произвольной длины, превышающих 2^53 – 1. BigInt создается с помощью добавления n в конец целочисленного литерала или путем вызова функции BigInt(), которая создает BigInt из строк, чисел и т.д.</li> <li><span>String</span> – строка (последовательность символов), например, 'JavaScript – главный язык интернета'.Строки записываются с использованием кавычек, можно использовать одинарные или двойные кавычки.</li> <li><span>Boolean</span> – логический (булев) тип, который может принимать значения true (истина) или false (ложь).</li> <li><span>Object</span> – объект. Это значение в памяти, на которое возможно сослаться с помощью идентификатора. Объект может расцениваться как набор свойств. Значения свойств могут иметь любой тип, включая другие объекты, что позволяет строить сложные, разветвленные иерархии данных.</li> <li><span>Null</span> – специальное значение, которое представляет «ничего», «пусто», или «неизвестное значение».</li> <li><span>Undefined</span> – это значение присваивается переменной, если она была объявлена, но не получила значения.</li> <li><span>Symbol</span> – это уникальный и неизменяемый тип данных, который можно использовать в качестве идентификатора для свойств объекта.</li> </ul>",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "habr.com",
      answer2:
        "<p>Часто кандидаты ошибаются, когда отвечают на этот вопрос, почему так происходит не понятно</p> <p>Всего в JS 8 типов данных:</p> <p><span>Число (number)</span>, <span>Строка (string)</span>, <span>Булевый (логический) тип (boolean)</span>, <span>BigInt</span>, <span>Symbol</span>, <span>undefiend</span>, <span>Object</span>, <span>Null</span></p>",
      image2: "",
      href3:
        "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName3: "proglib.io",
      answer3:
        "<p>Такой вопрос обычно оценивает ваши теоретические знания JavaScript. При ответе на этот вопрос рассмотрите возможность краткого перечисления всех примитивных типов данных, доступных в JavaScript.</p> <p><span>Ответ:</span>Фундаментальный тип данных, который не может быть создан от других типов данных. Он ограничен представлением одного значения. Все примитивы неизменяемы (immutable), не являются объектом и не имеют методов. По определению, все примитивы – встроенные типы данных, и компилятор должен знать их. Но не все встроенные типы данных – примитивы. В JavaScript доступно семь примитивных типов данных: <span>undefined, null, boolean, string, number, bigint, symbol</span>. Все остальное в JavaScript является объектом.</p>",
      image3: "",
    },
  },
  {
    id: 2,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#1",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для начала давайте поговорим о том, что у них общего.</p> <p>Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS (Number, String, Boolean, Symbol, undefined, null, BigInt).</p> <p>Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора '!!' является false.</p> <p><span>undefined («неопределенный»)</span> представляет собой значение по умолчанию:</p> <ul> <li>переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;</li> <li>функции, которая ничего не возвращает явно, например, console.log(1);</li> <li>несуществующего свойства объекта.</li> </ul> <p></p> В указанных случаях движок JS присваивает значение <span>undefined.</span> <p><img class='question__img' src='img/habr70/1.1habr70.png' alt=''></p> <p><span>null</span> — это «значение отсутствия значения». <span>null</span> — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:</p> <p><img class='question__img' src='img/habr70/1.2habr70.png' alt=''></p> <p>При сравнении <span>null</span> и <span>undefined</span> мы получаем <span>true</span>, когда используем оператор '==', и <span>false</span> при использовании оператора '==='. О том, почему так происходит, см. ниже.</p> <p><img class='question__img' src='img/habr70/1.3habr70.png' alt=''></p>",
      image1: "",
      href2:
        "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName2: "proglib.io",
      answer2:
        "<p>В JavaScript и <span>null</span>, и <span>undefined</span> представляют отсутствие значения, но они используются в разных контекстах и имеют разные семантические значения.</p> <p><span>Undefined</span> – присваивается переменной, когда она объявлена, но ей не присвоено конкретное значение.</p> <p><span>Null</span> – специальное значение, которое представляет «ничего», «пусто» или «неизвестное значение». Присваивается переменной вручную, чтобы указать, что она не должна иметь значения. Например, если нужно очистить значение переменной, можно установить его в null</p>",
      image2: "",
      href3: "https://habr.com/ru/articles/784548/",
      linkName3: "habr.com",
      answer3:
        "<p>Null и undefined - это два различных значения в JavaScript, которые указывают на отсутствие значения.</p> <p>Различия:</p> <ul> <li>null - это явное значение, которое указывает на отсутствие или намеренное присвоение пустого значения. undefined - это значение, которое указывает на отсутствие присвоенного значения</li> <li>null - это объектный тип данных, который представляет отсутствие объекта. undefined - это примитивный тип данных.</li> <li>null может быть присвоен явно, чтобы указать на отсутствие значения. undefined - это значение, которое присваивается переменной по умолчанию, когда она объявлена, но не инициализирована.</li> </ul> <p>Сходства:</p> <ul> <li>Осутствие значения: Оба значения, null и undefined, указывают на отсутствие значения.</li> <li>Истинность: Оба значения рассматриваются как ложные (falsy) в логическом контексте. Это означает, что они преобразуются в false, когда используются в условных выражениях.</li> <li>Присваивание: Оба значения могут быть присвоены переменным или свойствам объекта.</li> <li>Тип данных: Оба значения являются уникальными значениями и не имеют своих собственных типов данных.</li> </ul> <p>В целом, null используется, когда явно указывается отсутствие значения, в то время как undefined указывает на отсутствие присвоенного значения.</p>",
      image3: "",
    },
  },
  {
    id: 3,
    question: "В чем разница между null, undefined и undeclared?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>null - это в прямом смысле 'ничего'. Можно использовать это значение в качестве плейсхолдера.</p> <p>undefined - это значение для случая 'объявлено, но не инициализировано'.</p> <p>undeclared - это ошибка, возникающая в случае обращении к необъявленной переменной.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 4,
    question: "В чем разница между undefined и is not defined?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>undefined - это значение, присваемое объявленной, но не проинициализированной переменной. Мы получаем undefined, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку is not defined</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 5,
    question:
      "Почему typeof null возвращает object? Как проверить, является ли значение null?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#69",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>typeof null == 'object'</span> всегда будет возвращать <span>true</span> по историческим причинам. Поступало предложение исправить эту ошибку, изменив <span>typeof null = 'object'</span> на <span>typeof null = 'null'</span>, но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок)</p> <p>Для проверки, является ли <span>значение null</span> можно использовать <span>оператор строгого равенства (===)</span>:</p> <p><span>function isNull(value){<br> return value === null<br> }</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 6,
    question: "Какие значения в JS являются ложными?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#21",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>const falsyValues = ['', 0, null, undefined, NaN, false]</span><br>Ложными являются значения, результатом преобразования которых в логическое значение является false.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 7,
    question:
      "Что такое NaN? Какого типа это значение? Как проверить, является ли значение NaN?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#56",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>NaN</span> или <span>Not A Number (не число)</span> — это значение, получаемое в результате выполнения числовой операции над нечисловым значением</p> <p>В JS есть <span>встроенный метод isNaN</span>, позволяющий проверять, является ли значение <span>NaN</span></p>",
      image1: "",
      href2:
        "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName2: "proglib.io",
      answer2:
        "<p>Когда интервьюер просит дать определение термину, этот термин, как правило, является широко используемым. В этом случае, термин NaN, который означает «не число» – важная концепция, понимание которой, потребуется разработчикам на JavaScript при работе с числовыми значениями.</p> <p><span>Ответ:</span>Когда значение в операции не число, оно возвращает NaN. Это может произойти в нескольких случаях. Например, если операция возвращает неподходящий результат, потому что часть функции была нечисловой или результат имеет значение, не являющееся числовым.</p>",
      image2: "",
      href3:
        "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName3: "tproger.ru",
      answer3:
        "<p>Это специальное значение в JavaScript, которое означает «не число» (Not-a-Number).</p> <p>Возможные причины, по которым значение становится NaN:</p> <ul> <li>Попытка выполнить математическую операцию с нечисловым значением.</li> <li>Попытка выполнить математическую операцию, результат которой не может быть представлен числом, например деление нуля на ноль или вычисление квадратного корня из отрицательного числа.</li> <li>Преобразование строки в число, если строка не является валидным числом.</li></ul> <p>Значение NaN имеет интересное свойство: оно не равно ни одному другому значению, включая само себя. Поэтому существует специальная функция isNaN(), которая позволяет проверить, является ли значение NaN: <span>let result = isNaN(NaN); // result будет равен true, let result3 = isNaN(10); // result3 будет равен false, потому что 10 - это число</span></p>",
      image3: "",
      href4: "https://habr.com/ru/articles/784548/",
      linkName4: "habr.com",
      answer4:
        "<p>NaN расшифровывается как 'Not A Number', это 'false' (ложное) значение. Будьте аккуратны, выражение typeof NaN возвращает тип Number. Чтобы проверить значение переменной на соответствие NaN можно, воспользовавшись встроенным методом isNaN() или используя оператор тройного равенства ===.</p>",
      image4: "",
    },
  },
  {
    id: 8,
    question: "Как проверить, является ли значение ложным?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#22",
      linkName: "answer on habr.com",
      answer1:
        "<p>Следует использовать <span>функцию Boolean</span> или <span>оператор '!!'</span> (двойное отрицание).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 9,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "<p>Переменные, объявленные с помощью ключевого слова <span>«var»</span>, являются глобальными. Это означает, что они доступны из любого места в коде.</p> <p>Переменные, объявленные с помощью ключевых слов <span>«let»</span> и <span>«const»</span> имеют блочную область видимости. Это означает, что они доступны только внутри блока <span>({ })</span>.</p> <p>Разница между <span>«let»</span> и <span>«const»</span> состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью <span>const</span>, но не само свойство (переменную).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 10,
    question: "Какие способы объявления переменных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript есть четыре способа объявления переменных:</p> <p>1. <span>myVariable = 5;</span> – неявное объявление переменной. Оно создает глобальную переменную myVariable и присваивает ей значение 5, что может привести к ошибкам в строгом режиме ('use strict').</p> <p>2. <span>var myVariable = 5;</span> – явное объявление переменной с использованием ключевого слова var. Область видимости переменной myVariable может быть функциональной или глобальной, если она объявлена вне функции. Недостаток var состоит в том, что ее область видимости не ограничивается блоком, в котором используется переменная.</p> <p>3. <span>let myVariable = 5;</span>– явное объявление переменной с использованием ключевого слова let. Область видимости такой переменной ограничивается блоком, в котором она объявлена – на уровне функции она не видна</p> <p>4. <span>const myVariable = 5;</span> – это явное объявление переменной с использованием ключевого слова const. Переменная myVariable объявляется в области видимости блока, как и let. Однако, в отличие от let, переменная myVariable является неизменяемой – ее значение не может быть изменено после объявления, за одним исключением: если значение является объектом или массивом, его свойства или элементы могут быть изменены, но сама переменная все равно остается неизменяемой</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 11,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "<p>Переменные, объявленные с помощью ключевого слова <span>«var»</span>, являются глобальными. Это означает, что они доступны из любого места в коде.</p> <p>Переменные, объявленные с помощью ключевых слов <span>«let»</span> и <span>«const»</span> имеют блочную область видимости. Это означает, что они доступны только внутри блока <span>({ })</span>.</p> <p>Разница между <span>«let»</span> и <span>«const»</span> состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью <span>const</span>, но не само свойство (переменную).</p>",
      image1: "",
      href2:
        "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName2: "tproger.ru",
      answer2:
        "<p>let, var и const — это ключевые слова, используемые в JavaScript для объявления переменных.</p> <p>var долгое время был основным способом объявления переменных в JavaScript до появления let и const. var имеет область видимости функции и может быть изменен в любом месте в этой функции.</p> <p>let и const были добавлены в стандарт ECMAScript 6 (ES6) и имеют блочную область видимости. let может быть изменен, но const не может</p> <p>Используйте let, если вы собираетесь изменять значение переменной, и const, если не собираетесь. Используйте var, если вам нужно поддерживать совместимость со старыми браузерами или если вы хотите использовать его особенности, такие как функциональная область видимости.</p>",
      image2: "",
      href3: "https://habr.com/ru/articles/784548/",
      linkName3: "habr.com",
      answer3:
        "<p>Начнем с var:</p> <ul> <li>Переменные, объявленные с помощью var, имеют функциональную область видимости или область видимости внутри целого файла.</li> <li>Переменные var могут быть переопределены и переобъявлены в той же области видимости.</li> <li>Переменные var поднимаются (hoisted) в начало своей области видимости, что означает, что их можно использовать до их фактического объявления.</li> </ul> <p>let:</p> <ul> <li>Переменные, объявленные с помощью let, имеют блочную область видимости, ограниченную фигурными скобками {}.</li> <li>Переменные let не могут быть переобъявлены в той же области видимости, но могут быть переопределены.</li> <li>Переменные let не поднимаются (не hoisted) и не могут быть использованы до их объявления.</li> </ul> <p>const:</p> <ul> <li>Переменные, объявленные с помощью const, также имеют блочную область видимости.</li> <li>Переменные const должны быть инициализированы при объявлении и их значение не может быть изменено после этого.</li> <li>Переменные const не могут быть переобъявлены или переопределены.</li> <li>const также создает неизменяемую ссылку на объект, поэтому значения внутри объекта могут быть изменены, но сама ссылка остается неизменной.</li> </ul>",
      image3: "",
      href4: "https://habr.com/ru/articles/578370/",
      linkName4: "35 вопросов с собеседования JavaScript-разработчика",
      answer4:
        "<p>var </p> <ul> <li>поднимается в начало области видимости функции при компиляции;</li> <li>объявляет переменную, которая может быть перезаписана;</li> <li>объявляет переменную, которая может быть переопределена;</li> </ul> <p>let</p> <ul> <li>поднимается в начало области видимости блока при компиляции;</li> <li>объявляет переменную, которая может быть перезаписана;</li> <li>объявляет переменную, которая не может быть переопределена;</li> </ul> <p>const</p> <ul> <li>поднимается в начало области видимости блока при компиляции;</li> <li>объявляет переменную, которая не может быть перезаписана или переопределена</li> </ul>",
      image4: "",
    },
  },
  {
    id: 12,
    question: "Что такое область видимости (Scope)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#19",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Область видимости</span> — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).</p> <p><span>Глобальная область видимости</span> — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.</p> <p><img class='question__img' src='img/habr70/19.1habr70.png' alt=''></p> <p><span>Функциональная область видимости</span> (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.</p> <p><img class='question__img' src='img/habr70/19.2habr70.png' alt=''></p> <p><span>Блочная область видимости</span> — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.</p> <p><img class='question__img' src='img/habr70/19.3habr70.png' alt=''></p> <p><span>Область видимости</span> — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).</p> <p><img class='question__img' src='img/habr70/19.4habr70.png' alt=''></p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png' alt=''></p>",
      image1: "",
      href2: "https://doka.guide/js/closures/",
      linkName2: "DOKA.GUIDE",
      answer2:
        "<p>Не все переменные одинаково доступны — всё зависит от того, в каком месте кода их объявили.</p> <p>Разбираемся, почему так. Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.</p> <p>Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют области видимости.</p> <p><span>Область видимости</span> — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.</p> <p> Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом.</p> <p>Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка.</p> <p> Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки.</p> <p><span>Глобальная область видимости</span> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости. Переменные в глобальной области видимости называются глобальными переменными и доступны всем.</p> <p>Самый известный пример глобальной переменной — это <span>console</span>. JS в браузерах так устроен, что глобальные переменные попадают в объект <span></span>. Если очень грубо, то можно сказать, что window в случае браузера — это и есть глобальная область видимости.</p> <p><span>Модульная область видимости</span> - при использовании ES-модулей переменная, объявляемая вне функций, будет доступна, но только в том же модуле, где она создана. Чтобы предоставить доступ к определённым данным модуля, их нужно экспортировать. Разделение на модули упрощает задачу структурирования кода. Это особенно важно для больших проектов.</p> <p><span>Блочная область видимости</span> ограничена программным блоком, обозначенным при помощи { и }. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости.</p> <p><span>Функциональная область видимости</span>— это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции. Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.</p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 13,
    question:
      "В чем разница между областью видимости функции и блочной областью видимости?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>И то, и то является полноценной областью видимости. Различие наблюдается при использовании ключевого слова var, которое ограничивается только областью видимости функции, но не блочной областью видимости.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 14,
    question: "Что такое замыкание (Closures)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#20",
      linkName: "answer on habr.com",
      answer1:
        "Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание. По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures",
      linkName2: "mdn web docs",
      answer2:
        "<p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.</p> <p><span>Лексическая область видимости</span></p> <p>Рассмотрим следующий пример:</p> <p><img class='question__img' src='img/habr70/20.1habr70.png' alt=''></p> <p><span>init()</span> создаёт локальную переменную name и определяет функцию <span>displayName()</span>. <span>displayName()</span> — это внутренняя функция — она определена внутри <span>init()</span> и доступна только внутри тела функции <span>init()</span>. Обратите внимание, что функция <span>displayName()</span> не имеет никаких собственных локальных переменных. Однако, поскольку внутренние функции имеют доступ к переменным внешних функций, <span>displayName()</span> может иметь доступ к переменной name, объявленной в родительской функции <span>init()</span>.</p> <p>Выполните этот код и обратите внимание, что команда alert() внутри displayName() благополучно выводит на экран содержимое переменной name объявленной в родительской функции. Это пример так называемой лексической области видимости (lexical scoping): в JavaScript область действия переменной определяется по её расположению в коде (это очевидно лексически), и вложенные функции имеют доступ к переменным, объявленным вовне. Этот механизм и называется Lexical scoping (область действия, ограниченная лексически).</p> <p><span>Замыкание</span></p> <p>Рассмотрим следующий пример:</p> <p><img class='question__img' src='img/habr70/20.2habr70.png' alt=''></p> <p>На первый взгляд, кажется неочевидным, что этот код правильный, но он работает. В некоторых языках программирования локальные переменные-функции существуют только во время выполнения этой функции. После завершения выполнения <span>makeFunc()</span> можно ожидать, что переменная name больше не будет доступна. Однако, поскольку код продолжает нормально работать, очевидно, что это не так в случае JavaScript.</p> <p>Причина в том, что функции в <span>JavaScript</span> формируют так называемые <span>замыкания</span>. <span>Замыкание</span> — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. В рассмотренном примере <span>myFunc</span> — это ссылка на экземпляр функции <span>displayName</span>, созданной в результате выполнения <span>makeFunc</span>. Экземпляр функции <span>displayName</span> в свою очередь сохраняет ссылку на своё лексическое окружение, в котором есть переменная <span>name</span>. По этой причине, когда происходит вызов функции <span>myFunc</span>, переменная <span>name</span> остаётся доступной для использования и сохранённый в ней текст 'Mozilla' передаётся в alert.</p>",
      image2: "",
      href3:
        "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName3: "proglib.io",
      answer3:
        "<p><span>Замыкание (closure)</span> в JavaScript – это комбинация функции и лексического окружения, в котором эта функция была определена. Такая функция имеет доступ к переменным внешней функции, даже после того, как внешняя функция завершила выполнение</p> <p><img class='question__img' src='img/6proglibPart1.png' alt=''></p>",
      image3: "",
      href4: "https://habr.com/ru/articles/578370/",
      linkName4:
        "<p>Замыкание в JavaScript - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем.</p> <p>В следующем примере мы определяем функцию makeCounter(), которая фактически является фабричной функцией. При вызове она возвращает дочернюю функцию, которая имеет доступ к лексическому окружению внешней функции, то-есть функции makeCounter(). Таким образом, возвращаемая функция запоминает переменную counter и в последующем изменяет ее значение.</p> <p>function makeCounter(initial = 0) { let counter = initial;   return function() { return counter += 1;}} const counterA = makeCounter(0); console.log(counterA()); // 1 console.log(counterA()); // 2 const counterB = makeCounter(100); console.log(counterB()); // 101 console.log(counterB()); // 102</p>",
      image4: "",
    },
  },
  {
    id: 15,
    question: "Что такое поднятие (Hoisting)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#18",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Поднятие</span> — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.</p> <p>Для того, чтобы понять, что такое <span>Hoisting</span>, необходимо разобраться с тем, что представляет собой контекст выполнения.</p> <p><span>Контекст выполнения</span> — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.</p> <p><span>Компиляция.</span>В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).</p> <p><span>Выполнение.</span> В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.</p> <p><span>Запомните:</span> поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.</p> <p>Предположим, что у нас есть такой код:</p> <p><img class='question__img' src='img/habr70/3.1habr70.png' alt=''></p> <p>Получаем undefined, 1 и 'Hello Mark!'.</p> <p>Вот как выглядит фаза компиляции:</p> <p><img class='question__img' src='img/habr70/3.2habr70.png' alt=''></p> <p>После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.</p> <p>Дополнительно о Hoisting можно почитать<a class='question__link' href='https://developer.mozilla.org/ru/docs/Glossary/Hoisting' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Glossary/Hoisting",
      linkName2: "mdn web docs_",
      answer2:
        "Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. Однако, hoisting может привести и к недоразумениям. Например, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.",
      image2: "",
      href3: "https://habr.com/ru/articles/578370/",
      linkName3: "35 вопросов с собеседования JavaScript-разработчика",
      answer3:
        "<p>Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.</p> <p>Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.</p> <p>По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression.</p>",
      image3: "",
    },
  },
  {
    id: 16,
    question: "Для чего используется оператор ' && ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#2",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '&&' (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: console.log(false && 1 && []) // false, console.log(' ' && true && 5) // 5. При этом второй операнд не вычисляется.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 17,
    question: "Для чего используется оператор ' || ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#3",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '||' (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 18,
    question: "Для чего используется оператор '!!'?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#16",
      linkName: "answer on habr.com",
      answer1:
        "<p>Оператор '!!' (двойное отрицание) приводит значение справа от него к логическому значению.</p> <p><span>console.log(!!null) // false,<br>console.log(!!undefined) // false,<br>console.log(!![])  //true,<br>console.log(!!1)  //true</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 19,
    question: "В чем разница между операторами ' == ' и ')' === ' ?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "answer on habr.com",
      answer1:
        "<p>Разница между оператором '==' (абстрактное или нестрогое равенство) и оператором '===' (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.</p> <p>Преобразование представляет собой процесс приведения значения к другому типу или, точнее, процесс приведения сравниваемых значений к одному типу. При сравнении оператор '==' производит так называемое неявное сравнение. Оператор '==' выполняет некоторые операции перед сравнением двух значений.</p> <p>Допустим, мы сравниваем x и y.</p> <p>Алгоритм следующий:</p> <ol> <li>Если x и y имеют одинаковый тип, сравнение выполняется с помощью оператора '==='.</li> <li>Если x = null и y = undefined возвращается true.</li> <li>Если x = undefined и y = null возвращается true.</li> <li>Если x = число, а y = строка, возвращается x == toNumber(y) (значение y преобразуется в число).</li> <li>Если x = строка, а y = число, возвращается toNumber(x) == y (значение x преобразуется в число).</li> <li>Если x = логическое значение, возвращается toNumber(x) == y.</li> <li>Если y = логическое значение, возвращается x == toNumber(y).</li> <li>Если x = строка, символ или число, а y = объект, возвращается x == toPrimitive(y) (значение y преобразуется в примитив).</li> <li>Если x = объект, а y = строка, символ или число, возвращается toPrimitive(x) == y.</li> <li>Возвращается false.</li></ol> <p>Запомните: для приведения объекта к «примитиву» метод toPrimitive сначала использует метод valueOf, затем метод toString.</p> <p>Примеры:</p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png' alt=''></p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png' alt=''></p> <p>Если же мы используем оператор '===' все примеры, кроме первого, вернут false, поскольку значения в этих примерах имеют разные типы.</p>",
      image1: "",
      href2:
        "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName2: "proglib.io",
      answer2:
        "<p>В JavaScript операторы == и === используются для сравнения двух значений, но они работают по-разному:</p> <p>== проверяет на <span>абстрактное равенство</span>, то есть он преобразует типы данных перед сравнением – например, если вы сравниваете строку с числом, JavaScript преобразует строку в число перед сравнением. Если строка не может быть преобразована в число, она преобразуется в NaN, что возвращает false. Если оба операнда имеют <span>разные</span> типы данных, но они могут быть преобразованы в один и тот же <span>тип</span> данных и имеют одно и то же <span>значение</span>, оператор== вернетtrue:</p> <p><img class='question__img' src='img/1.1proglibPart1.png' alt=''></p> <p>=== проверяет на <span>строгое равенство</span>, то есть он не выполняет преобразование типов данных. Если два значения имеют разные типы данных, оператор === вернет false, даже если они имеют одно и то же значение. Если оба операнда имеют <span>одинаковый</span> тип данных и <span>одинаковое</span> значение, оператор === вернет true:</p> <p><img class='question__img' src='img/1.2proglibPart1.png' alt=''>",
      image2: "",
      href3: "https://habr.com/ru/articles/784548/",
      linkName3: "habr.com",
      answer3:
        "<p>В JavaScript операторы сравнения == (двойное равенство) и === (тройное равенство) используются для сравнения значений. Они имеют следующие различия:</p> <p>== (двойное равенство):</p> <ul> <li>Оператор == выполняет нестрогое сравнение, сравнивая значения с приведением типов, если это необходимо.</li> <li>Если типы операндов различаются, JavaScript пытается привести их к одному типу перед сравнением.</li> <li>Например, при сравнении числа и строки, строка будет преобразована в число перед сравнением.</li> </ul> <p>=== (тройное равенство):</p> <ul> <li>Оператор === выполняет строгое сравнение, сравнивая значения без приведения типов.</li> <li>Он сравнивает значения и типы операндов, и возвращает true только если они идентичны.</li> </ul>",
      image3: "",
    },
  },
  {
    id: 20,
    question:
      "Почему результатом сравнения двух похожих объектов является false?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#15",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>let a = {a: 1} <br> let b = {a: 1} <br> let c = a <br> console.log(a === b) // <br> false console.log(a === c) // true</span></p> <p>В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 21,
    question:
      "Является ли использование унарного плюса (оператор ' + ') самым быстрым способом преобразования строки в число?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#4",
      linkName: "answer on habr.com",
      answer1:
        "Согласно MDN оператор " +
        " действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 22,
    question: "Что такое DOM?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#5",
      linkName: "answer on habr.com",
      answer1:
        "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.",
      image1: "",
      href2: "https://learn.javascript.ru/dom-nodes",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Основой HTML-документа являются теги.В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.",
      image2: "",
      href3:
        "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName3: "proglib.io",
      answer3:
        "<p><span>DOM</span>  (Document Object Model) – это модель, которая представляет HTML-документ в виде <span>дерева тегов</span>. Каждый HTML-тег в этом дереве является объектом. Вложенные теги являются дочерними элементами по отношению к своему родительскому элементу. Текст внутри тега также является объектом. Все эти объекты доступны для любых манипуляций с помощью JavaScript, а эти манипуляции, в свою очередь, позволяют динамически управлять содержимым страницы.</p> <p>Статья по теме: <a class='question__link' href='https://proglib.io/p/dom-chto-takoe-obektnaya-model-dokumenta-prostymi-slovami-2022-02-18' target='_blank' rel='noopener noreferrer'>DOM: что такое объектная модель документа простыми словами</a></p> <p><img class='question__img' src='img/21proglibPart2.png' alt=''></p>",
      image3: "",
      href4: "https://habr.com/ru/articles/578370/",
      linkName4: "35 вопросов с собеседования JavaScript-разработчика",
      answer4:
        "<p>DOM - Document Object Model (объектная модель документа). Другими словами, это дерево всех узлов страницы, которые распознал браузер в процессе обработки HTML-разметки.</p> <p>DOM - это интерфейс, позволяющий JavaScript-коду взаимодействовать с шаблоном.</p>",
      image4: "",
    },
  },
  {
    id: 23,
    question: "Что такое теневой DOM?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Shadow DOM</span> – это техника, позволяющая создавать изолированные фрагменты HTML и CSS в специальном сегменте DOM, который находится внутри определенного элемента. Такой подход позволяет исключить влияние инкапсулированных стилей на структуру и внешний вид основной страницы, и обеспечивает большую гибкость и контроль над представлением и поведением элементов.</p> <p>В приведенном ниже примере инкапсулированные стили пользовательского элемента не влияют на внешний вид остальной части страницы</p>  <p><img class='question__img' src='img/25proglibPart2.png' alt=''></p> <img class='question__img' src='https://media.proglib.io/posts/2024/01/10/9a73b0cff11a40d5727227b04360a489.png' alt=''>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 24,
    question: "Что такое распространение события (Event Propogation)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#6",
      linkName: "answer on habr.com",
      answer1:
        "<p>Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:</p> <ol> <li>Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.</li> <li>Целевая фаза — это когда событие достигает целевого элемента.</li> <li>Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.</li> </ol> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png' alt=''></p> <p>Подробнее о распространении событий можно почитать <a class='question__link' href='https://learn.javascript.ru/bubbling-and-capturing' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://www.w3.org/TR/uievents/#event-flow' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 25,
    question: "Что такое всплытие события (Event Bubbling)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#7",
      linkName: "answer on habr.com",
      answer1:
        "<p>Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.</p> <p>Допустим, у нас есть такая разметка:</p> <p><img class='question__img' src='img/habr70/2.1habr70.png' alt=''></p> <p>И такой JS:</p> <p><img class='question__img' src='img/habr70/2.2habr70.png' alt=''></p> <p>У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.</p>",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. Поэтому если кликнуть на <p>, то мы увидим три оповещения: p → div → form.Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде. Почти все события всплывают. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают. Всегда можно узнать, на каком конкретно элементе произошло событие. Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target. Отличия от this (=event.currentTarget): 1. event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен. 2. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик. Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 26,
    question: "Что такое погружение события (Event Capturing)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#8",
      linkName: "answer on habr.com",
      answer1:
        "<p>Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков</p> <p>Допустим, у нас есть такая разметка:</p> <p><img class='question__img' src='img/habr70/2.1habr70.png' alt=''></p> <p>И такой JS:</p> <p><img class='question__img' src='img/habr70/2.2habr70.png' alt=''></p> <p>У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.</p>",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной. То есть при клике на <td> событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики. Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах. Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так: elem.addEventListener(..., {capture: true}) Существуют два варианта значений опции capture: Если аргумент false (по умолчанию), то событие будет поймано при всплытии. Если аргумент true, то событие будет перехвачено при погружении.  Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение. ",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 27,
    question:
      "В чем разница между методами event.preventDefault() и event.stopPropagation()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#9",
      linkName: "answer on habr.com",
      answer1:
        "<p>Метод <span>event.preventDefault()</span> отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).</p>",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для этого нужно вызвать <span>метод event.stopPropagation()</span>. <span>Event.preventDefault()</span> Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п. Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события. Вызов <span>event.preventDefault()</span> является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.",
      image2: "",
      href3: "https://doka.guide/js/event-prevent-default/",
      linkName3: "DOKA.GUIDE",
      answer3:
        "Методы <span>event.preventDefault()</span> и <span>event.stopPropagation()</span> предназначены для решения похожих задач и часто используются вместе. <span>Метод event.stopPropagation()</span> останавливает распространение события <span>(event propagation)</span>. Распространение события включает стадию захвата и стадию всплытия. Например, рассмотрим обработку события на стадии захвата — при распространении события от родительских элементов к дочерним. Обработчик, объявленный в дочернем элементе, не будет вызван после выполнения <span>stopPropagation()</span> в обработчике родительского элемента. При этом действие по умолчанию не отменится. <span>Метод event.preventDefault()</span> отменяет действие по умолчанию. Например, переход по ссылке при клике на элемент <a>. Само событие продолжает распространяться после выполнения <span>preventDefault()</span>.",
      image3: "",
    },
  },
  {
    id: 28,
    question: "Как узнать об использовании метода event.preventDefault()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#10",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода <span>event.preventDefault</span>.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 29,
    question: "Что такое цель события или целевой элемент (event.target)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#12",
      linkName: "answer on habr.com",
      answer1:
        "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 30,
    question: "Что такое текущая цель события (event.currentTarget)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#13",
      linkName: "answer on habr.com",
      answer1:
        "Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 31,
    question: "Что такое шаблонные литералы (Template Literals) / (бэктики)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#45",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Шаблонные литералы</span> — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``)</p> <p><img class='question__img' src='img/habr70/45habr70.png' alt=''></p> <p>В ES6 нам не нужно использовать конкатенацию строк для объединения текста с переменной: мы можем использовать выражение <span>${expr}</span> для получения значения переменной.</p>",
      image1: "",
      href2:
        "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName2: "proglib.io",
      answer2:
        "<p><span>Шаблонные строки (template literals)</span>в JavaScript – это новый способ работы со строками, введенный в ECMAScript 6 (ES6). Они обозначаются обратными кавычками ` вместо одинарных или двойных кавычек. Шаблонные строки позволяют создавать многострочные строки без необходимости использования специальных символов или конкатенации строк:</p> <p><img class='question__img' src='img/7.1proglibPart1.png' alt=''></p> <p>Шаблонные строки также поддерживают интерполяцию строк, что позволяет вставлять выражения прямо в строку. Эти выражения заключаются в фигурные скобки ${expression} и вычисляются при создании строки:</p> <p><img class='question__img' src='img/7.2proglibPart1.png' alt=''></p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 32,
    question: "Что такое тернарный оператор и как он работает?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Тернарный оператор – это сокращенная форма записи <span>if-else</span>. Он называется тернарным, потому что является единственным оператором в JavaScript, который принимает <span>три</span> аргумента. Синтаксис тернарного оператора:</p> <p><span>условие ? выражение_если_истинно : выражение_если_ложно</span></p> <p>Условие – любое условие, которое возвращает <span>true</span> или <span>false</span>.</p> <p>Выражение для истинного условия – что нужно вернуть, если условие истинно.</p> <p>Выражение для ложного условия – что нужно вернуть, если условие ложно.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 33,
    question: "Что такое регулярные выражения?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Регулярные выражения (regex) – это паттерны, которые используются для поиска и замены текста в строках. В паттернах используются комбинации специальных символов (шаблоны) и флаги (модификаторы, которые определяют поведение поиска). Регулярные выражения часто используют в комбинации с этими методами:</p> <ul> <li><span>test()</span> – проверка на соответствие шаблону</li> <li><span>match()</span> – поиск соответствий</li> <li><span>replace()</span> – замена по шаблону</li> <li><span>search()</span> – поиск индекса</li> </ul> <p>Составлять регулярные выражения можно с помощью конструктора RegExp или литеральной нотации.</p> <p><a class='question__link' href='https://proglib.io/p/shpargalka-po-regulyarnym-vyrazheniyam-v-javascript-2022-07-17' target='_blank' rel='noopener noreferrer'>Шпаргалка по регулярным выражениям в JavaScript</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 34,
    question: "Для чего используется директива «use strict»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#23",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>«use strict»</span> — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.</p> <p>Вот какие ограничения накладывает строгий режим:</p> <p>1. Нельзя присваивать значения или обращаться к необъявленным переменным </p> <p>2. Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи</p> <p>3. Нельзя удалить «неудаляемое» свойство объекта</p>  <p>4. Запрещено дублирование параметров</p>  <p>5. Нельзя создавать функции с помощью функции eval</p> <p>6. Значением «this» по умолчанию является undefined</p> ",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "answer habr.com",
      answer2:
        "<p>Директива 'use strict' используется в JavaScript для включения строгого режима выполнения кода. Когда эта директива указана в начале скрипта или функции, JavaScript выполняет код в строгом режиме, что означает, что некоторые неявные или устаревшие функции и конструкции языка будут запрещены или изменены, а некоторые ошибки будут вызывать исключения.</p> <p>В основном используется для:</p> <ul> <li>Предотвращение ошибок</li> <li>Устранение неявных глобальных переменных</li> <li>Запрет использования некоторых устаревших функций и конструкций</li> <li>Улучшение безопасности</li> </ul>",
      image2: "",
      href3: "https://habr.com/ru/articles/578370/",
      linkName3: "35 вопросов с собеседования JavaScript-разработчика",
      answer3:
        "<p>Команда use strict включает так называемый строгий режим. В этом режиме предупреждения становятся ошибками, что помогает в написании более чистого и безопасного кода, менее уязвимого к ошибкам в продакшене.</p>",
      image3: "",
    },
  },
  {
    id: 35,
    question:
      "Какое значение имеет this? Что такое this? Отличие this в function declaration и стрелочных функциях",
    answer: {
      href: "https://habr.com/ru/articles/486820/#24",
      linkName: "answer on habr.com",
      answer1:
        "<p>Обычно <span>this</span> ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение <span>this</span> меняется в зависимости от контекста выполнения, от того места, где мы используем <span>this</span></p> <p><img class='question__img' src='img/habr70/24habr70.png' alt=''></p> <p>В данном случае метод getName возвращает this.name, а this ссылается на carDetails, объект, в котором выполняется getName, который является ее «владельцем».</p>",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "habr.com",
      answer2:
        "<p>this - это специальное ключевое слово в JavaScript, которое ссылается на объект, в контексте которого выполняется текущий код. Значение this зависит от контекста вызова функции и может быть разным в различных ситуациях.</p> <p>Функции (function declaration):</p> <ul> <li>В функциях объявления значение this определяется во время выполнения функции, в зависимости от способа вызова функции.</li> <li>Если функция вызывается как метод объекта, то this ссылается на сам объект, на котором вызывается метод.</li> <li>Если функция вызывается как обычная функция, то this ссылается на глобальный объект (в браузере это объект window).</li> </ul> <p>Стрелочные функции (arrow functions):</p> <ul> <li>В стрелочных функциях значение this определяется лексически, оно берется из окружающего контекста, в котором функция была определена.</li> <li>Стрелочные функции не имеют своего собственного this, поэтому они не создают новый контекст this и не зависят от способа вызова.</li> <li>Вместо этого, this в стрелочных функциях ссылается на this окружающего контекста.</li> </ul>",
      image2: "",
      href3: "https://habr.com/ru/articles/578370/",
      linkName3: "35 вопросов с собеседования JavaScript-разработчика",
      answer3:
        "<p>this указывает на объект области видимости во время выполнения. По умолчанию this указывает на глобальный объект. В браузере выражение this === window будет истинно.</p>",
      image3: "",
    },
  },
  {
    id: 36,
    question: "Что такое прототип объекта?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#25",
      linkName: "answer on habr.com",
      answer1:
        "<p>В двух словах, <span>прототип</span> — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. </p> <p><span>const o = {}<br>console.log(o.toString()) // [object Object]</span></p> <p>Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится <span>Object.prototype</span>.</p> <p><span></span></p> <p>Подробнее о прототипах и наследовании можно почитать <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://learn.javascript.ru/prototype-inheritance' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "https://learn.javascript.ru/prototype-inheritance",
      linkName2:
        "В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип». Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Операция записи не использует прототип. Прототип используется только для чтения свойств.",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 37,
    question: "Как создать объект, не имеющий прототипа?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#38",
      linkName: "answer on habr.com",
      answer1: "<p>Это можно сделать с помощью <span>Object.create</span></p>",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "habr.com",
      answer2:
        "<p>В JavaScript объекты обычно наследуют свойства и методы от своих прототипов. Однако, существует несколько способов создания объекта без прототипа:</p> <p>Использование Object.create(null): Метод Object.create(null) создает новый объект с указанным прототипом null, что означает, что объект не будет наследовать свойства и методы от какого-либо прототипа.</p> <p>Пример: <span>const obj = Object.create(null); console.log(obj.toString); // Вывод: undefined</span></p> <p>Использование литерала объекта и null в качестве прототипа: Можно создать объект, используя литерал объекта и установив его прототип в null.</p> <p>Пример: <span>const obj = Object.setPrototypeOf({}, null); console.log(obj.toString); // Вывод: undefined</span></p> <p>Использование функции-конструктора без прототипа: Можно создать функцию-конструктор, которая не имеет прототипа, и создать объект с помощью этой функции.</p> <p>Пример: <span>function NoPrototype() { // Пустая функция-конструктор без прототипа } const obj = new NoPrototype(); console.log(obj.toString); // Вывод: undefined</span></p> <p>Обратите внимание, что объекты без прототипа могут быть полезны в определенных случаях, но они также могут ограничивать функциональность и использование стандартных методов и свойств. Поэтому рекомендуется использовать объекты без прототипа с осторожностью и только в случаях, когда это действительно необходимо.</p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 38,
    question: "Что такое прототипное наследование?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Прототипное наследование </span>в JavaScript – это механизм, который позволяет одному объекту наследовать свойства и методы другого объекта. Это основной способ наследования в JavaScript.</p> <p>Каждый объект в JavaScript имеет внутреннее скрытое свойство prototype, которое ссылается на другой объект. Этот другой объект называется прототипом первого объекта. При попытке получить доступ к свойству объекта, JavaScript сначала проверяет, есть ли это свойство в самом объекте. Если нет, он ищет его в прототипе объекта. Если и там его нет, то в прототипе прототипа и так далее. Если свойство или метод отсутствуют в объекте и его прототипе, JavaScript вернет undefined</p><p><img class='question__img' src='img/23proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 39,
    question: "С помощью чего в JS реализуются наследование?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>В JavaScript наследование реализуется с помощью прототипов. Прототипное наследование - это механизм, который позволяет объектам наследовать свойства и методы других объектов. Еще появился новый в ECMAScript 2015 с помощью ключевого слова class.</p> <p>Каждый объект в JavaScript имеет внутреннюю ссылку на прототип (prototype), которая указывает на другой объект. </p> <p>Существует несколько способов реализации наследования в JavaScript, рассмотрим их все.</p> <p>Прототипное наследование с использованием prototype:</p> <ul> <li>Создается конструктор (функция-класс), у которого есть свойство prototype.</li> <li>Создаются новые объекты с помощью этого конструктора с помощью ключевого слова new.</li> <li>Прототип нового объекта устанавливается равным прототипу конструктора.</li> </ul> <p>Наследование с использованием class (введено в ECMAScript 2015):</p> <ul> <li>Используется ключевое слово class для определения класса.</li> <li>Используется ключевое слово extends для указания родительского класса.</li> <li>Методы родительского класса могут быть переопределены или расширены в дочернем классе с помощью ключевого слова super.</li> </ul>",
      image1: "",
      href2: "https://habr.com/ru/articles/578370/",
      linkName2: "35 вопросов с собеседования JavaScript-разработчика",
      answer2:
        "<p>Если отвечать кратко, в JavaScript все является объектами. Эти объекты связаны цепочками прототипов, по которым им передаются методы и свойства. При обращении к свойству или методу объекта сначала происходит поиск этого свойства у самого объекта. В случае неудачи поиск перенаправляется в его прототип, затем в прототип прототипа и так далее, пока искомое свойство не будет найдено, либо пока не закончится цепочка прототипов.</p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 40,
    question: "Что такое функции высшего порядка (Higher Order Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#32",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Функция высшего порядка</span> — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.</p> <p><span>function higherOrderFunction(param, callback)<br>{ return callback(param) }</span></p>",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "habr.com",
      answer2:
        "<p>Функции высшего порядка - это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. В JavaScript функции высшего порядка являются мощным инструментом, позволяющим создавать более гибкий и модульный код. Вот несколько примеров функций высшего порядка:</p> <p>Функция обратного вызова (Callback): Функция, которая передается в качестве аргумента в другую функцию и вызывается внутри нее. Это позволяет передавать логику выполнения внутрь другой функции.</p> <p>Пример: <span>function add(a, b) { return a + b; }</span></p> <p>Функция обертка (Wrapper): Функция, которая принимает другую функцию и возвращает новую функцию, добавляя дополнительную логику или изменяя поведение оригинальной функции.</p>",
      image2: "",
      href3: "https://habr.com/ru/articles/578370/",
      linkName3: "35 вопросов с собеседования JavaScript-разработчика",
      answer3:
        "<p>Функция, принимающая функцию обратного вызова в качестве аргумента.</p>",
      image3: "",
    },
  },
  {
    id: 41,
    question:
      "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#33",
      linkName: "answer on habr.com",
      answer1:
        "<p>Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 42,
    question: "Как в JS вызвать функцию?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#66",
      linkName: "answer on habr.com",
      answer1:
        "<p>В JS существует 4 способа вызвать функцию. Вызов определяет значение this или «владельца» функции.</p> <p><span>Вызов в качестве функции.</span> Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window:</p> <p><img class='question__img' src='img/habr70/66.1habr70.png' alt=''></p> <p><span>Вызов в качестве метода.</span> Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением <span>this</span> становится объект этого метода:</p> <p><img class='question__img' src='img/habr70/66.2habr70.png' alt=''></p> <p><span>Вызов в качестве конструктора.</span> Когда функция вызывается с использованием <span>ключевого слова «new»</span>, мы называем такую функцию <span>конструктором</span>. При этом создается пустой объект, являющийся значением <span>this</span>:</p> <p><img class='question__img' src='img/habr70/66.3habr70.png' alt=''></p> <p><span>Вызов с помощью методов apply или call.</span> Мы используем эти методы, когда хотим явно определить значение <span>this</span> или владельца функции:</p> <p><img class='question__img' src='img/habr70/66.4habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 43,
    question: "Для чего используется метод Function.prototype.apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#27",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Apply</span> используется для привязки определенного объекта к значению this вызываемой функции.</p> <p><img class='question__img' src='img/habr70/27.1habr70.png' alt=''></p> <p>Этот метод похож на <span>Function.prototype.call</span>. Единственное отличие состоит в том, что в <span>apply</span> аргументы передаются в виде массива.</p> <p><img class='question__img' src='img/habr70/27.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 44,
    question: "Для чего используется метод Function.prototype.call?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#28",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Call</span> используется для привязки определенного объекта к значению this вызываемой функции.</p> <p><img class='question__img' src='img/habr70/28.1habr70.png' alt=''></p> <p>Этот метод похож на <span>Function.prototype.apply</span>. Отличие состоит в том, что в <span>call</span> аргументы передаются через запятую.</p> <p><img class='question__img' src='img/habr70/28.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 45,
    question: "Для чего используется метод Function.prototype.bind?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#30",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Bind</span> возвращает новую функцию, значением <span></span>this которой является объект, указанный в качестве первого параметра. В отличие от <span>bind</span>, <span>call</span> и <span>apply</span> сразу же вызывают функцию.</p> <p><img class='question__img' src='img/habr70/30habr70.png' alt=''></p>",
      image1: "",
      href2: "https://habr.com/ru/articles/578370/",
      linkName2: "35 вопросов с собеседования JavaScript-разработчика",
      answer2:
        "<p>Данный метод возвращает функцию, по отношению к которой он вызывается, но с подмененным контекстом.</p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 46,
    question: "В чем разница между методами call, apply, bind?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#29",
      linkName: "answer on habr.com",
      answer1:
        "<p>Отличие между <span>call</span> и <span>apply</span> состоит в том, как мы передаем аргументы в вызываемой функции. В <span>apply</span> аргументы передаются в виде массива, в <span>call</span> — через запятую.</p> <p><span>reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15 <br> reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15</span></p>",
      image1: "",
      href2:
        "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName2: "tproger.ru",
      answer2:
        "<p>Методы .call() и .apply() используются для вызова функции с заданным значением this, а также для передачи аргументов в функцию. Основная разница между ними заключается в способе передачи аргументов.</p> <p>Метод .call() принимает список аргументов, переданных в функцию через запятую. В то же время, метод .apply() принимает массив аргументов, переданных в функцию.</p> <p>Вот пример использования методов .call() и .apply():</p> <p>function greet(name, age) {console.log(`Hello, my name is ${name} and I am ${age} years old.`); }</p> <p>greet.call(null, 'John', 30);</p> <p>greet.apply(null, ['Jane', 25]);</p> <p>В обоих случаях мы вызываем функцию greet() с this равным null. В первом случае мы передаем два аргумента в функцию через запятую, а во втором случае мы передаем массив из двух аргументов в функцию.</p> <p>Понравился такой формат? Держите ещё 15 интересных вопросов к собеседованию фронтенд. Проверьте себя: пишите свои ответы в комментариях.</p>",
      image2: "",
      href3: "https://habr.com/ru/articles/784548/",
      linkName3: "habr.com",
      answer3:
        "<p>Методы call, apply и bind являются частью языка JavaScript и используются для управления контекстом выполнения функций. Вот их основные различия:</p> <p><span>call:</span> Этот метод вызывает функцию с указанным контекстом и аргументами, переданными в виде отдельных аргументов. Синтаксис метода call выглядит следующим образом: function.call(context, arg1, arg2, ...). При использовании call аргументы передаются в виде списка, разделенного запятыми.</p> <p><span>apply:</span> Этот метод вызывает функцию с указанным контекстом и аргументами, переданными в виде массива. Синтаксис метода apply выглядит следующим образом: function.apply(context, [arg1, arg2, ...]). При использовании apply аргументы передаются в виде массива.</p> <p><span>bind:</span> Этот метод создает новую функцию, привязанную к указанному контексту. Он не вызывает функцию немедленно, а возвращает новую функцию, которую можно вызвать позже. Синтаксис метода bind выглядит следующим образом: function.bind(context). При использовании bind контекст функции фиксируется, и при вызове новой функции этот контекст будет сохраняться.</p>",
      image3: "",
    },
  },
  {
    id: 47,
    question: "Как изменить контекст функции?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Изменить контекст функции можно с помощью методов <span>bind()</span>, <span>call()</span> и <span>apply()</span>.</p> <p>Метод <span>bind()</span> возвращает новую функцию с привязанным контекстом:</p> <p><img class='question__img' src='img/18.1proglibPart1.png' alt=''></p> <p>Метод <span>call() </span>принимает последовательность аргументов, а <span>apply()</span> принимает массив аргументов в качестве второго параметра:</p> <p><img class='question__img' src='img/18.2proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },

  {
    id: 48,
    question: "Что такое IIFE (Immediately Invoked Function Expression)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#26",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>IIFE</span> или <span>Immediately Invoked Function Expression</span> — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания <span>IIFE</span> необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так:<br><span>(function( ) { }( )), <br>(function( ) { })( )</span></p>",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "habr.com",
      answer2:
        "<p>IIFE (Immediately Invoked Function Expression) - это выражение функции, которое вызывается немедленно после его определения. Оно позволяет создавать локальную область видимости для переменных и функций, чтобы избежать конфликтов имен и сохранить приватность данных.</p> <p>IIFE обычно используется для создания модулей, эмуляции блока кода с областью видимости или для выполнения некоторых инициализаций при загрузке страницы.</p> <p>Пример IIFE: <span>(function() {   // Код, который будет выполнен немедленно  var x = 5; console.log(x); // Выводит 5 })();</span> </p> <p>В приведенном примере, функция обернута в круглые скобки (function() { ... }), чтобы превратить ее в выражение. Затем, после закрывающей скобки, добавляются еще одни круглые скобки () для вызова функции немедленно.</p> <p>IIFE может принимать аргументы, например: <span>(function(name) { console.log('Hello, ' + name); })('John'); // Выводит 'Hello, John'</span></p> <p>IIFE также может возвращать значение, которое может быть присвоено переменной: </p> <p><span>var result = (function() { return 5 + 3; })(); console.log(result); // Выводит 8</span></p> <p>Использование IIFE помогает изолировать код и предотвращает его влияние на глобальную область видимости, что способствует более безопасному и организованному коду.</p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 49,
    question:
      "В чем разница между объявлением функции и функциональным выражением?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Объявление функции и функциональное выражение</span> – это два способа определения функций в JavaScript.</p> <p><span>Объявление функции</span>  – это традиционный способ определения функции. Функция создается и присваивается переменной, как любое другое значение. При этом объявленные функции доступны во всем коде, даже до того, как программа достигает того участка, где они определены.</p> <p><img class='question__img' src='img/27.1proglibPart2.png' alt=''></p> <p><span>Функциональное выражение</span>  – это альтернативный способ определения функции:</p> <p><img class='question__img' src='img/27.2proglibPart2.png' alt=''></p> <p>В отличие от традиционной функции, функциональное выражение <span>нельзя</span> вызывать до определения в коде – это приведет к ошибке . Функциональные выражения могут:</p> <ul> <li>быть анонимными;</li> <li>формировать замыкания;</li> <li>передаваться в качестве аргументов другим функциям;</li> <li>использоваться как немедленно вызываемые функциональные выражения (IIFE).</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 50,
    question: "Зачем оборачивать содержимое исходного JS-файла в блок функции?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Ответ на этот вопрос может показать ваши знания вспомогательных процессов, которые, скорее всего, специфичны для библиотеки.</p> <p><span>Ответ:</span> Этот метод заключает в себя содержимое файла, создавая приватное пространство имен. Такая реализация позволяет избежать конфликта между объектами JavaScript и библиотеками, в которых они размещены.</p>",
      image1: "",
      href2: "https://habr.com/ru/articles/578370/",
      linkName2: "35 вопросов с собеседования JavaScript-разработчика",
      answer2:
        "<p>Этот шаблон называется <span>IIFE - Immediately Invoked Function Expression</span>  (немедленно вызываемое функциональное выражение). Этот подход позволяет:</p> <ul> <li>обеспечить коду собственный блок видимости, то-есть контекст выполнения,</li> <li>избежать загрязнения глобальной области видимости глобальными переменными,</li> <li>избежать неумышленного переопределения уже существующих переменных в глобальной области видимости</li> </ul>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 51,
    question: "Что такое функции-конструкторы?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>онструкторы в JavaScript – это специальные функции, используемые для создания объектов. Вот два основных правила при работе с конструкторами:</p> <ul> <li>Имя конструктора должно начинаться с заглавной буквы.</li> <li>Конструктор вызывается при помощи оператора new.</li> </ul> <p>Когда мы вызываем конструктор через new, происходит следующее:</p> <ul> <li>Создается новый пустой объект и присваивается в this.</li> <li>Выполняется код внутри конструктора. Обычно он модифицирует объект this, добавляя в него свойства.</li> <li>Значение this возвращается из конструктора как результат.</li> </ul> <p>Например: <img class='question__img' src='img/28proglibPart2.png' alt=''></p> <p>Здесь User – функция-конструктор. Когда мы вызываем конструктор через new User('Вася'), создается объект userс указанным именем и методом sayHi. Таким образом с помощью конструкторов можно многократного создавать объекты по одному шаблону.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },

  {
    id: 52,
    question: "Для чего используется ключевое слово «new»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#70",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Ключевое слово «new»</span> используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).</p> <p>Допустим, у нас есть такой код:</p> <p><img class='question__img' src='img/habr70/70habr70.png' alt=''></p> <ul> Ключевое слово «new» делает 4 вещи: <li>1. Создает пустой объект.</li> <li>2. Привязывает к нему значение this.</li> <li>3. Функция наследует от functionName.prototype.</li> <li></li> <li>4. Возвращает значение this, если не указано иное.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 53,
    question: "Что такое классы (Classes)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#44",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Классы</span> — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование.</p> <p><img class='question__img' src='img/habr70/44.1habr70.png' alt=''></p> <p><img class='question__img' src='img/habr70/44.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 54,
    question: "Как происходит наследование классов в ES6?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Наследование классов в ES6</span> осуществляется с помощью ключевого слова extends, которое следует за именем родительского класса. Родительский класс часто называют базовым классом, а класс, который наследует базовый/родительский класс, называется производным или дочерним</p> <p><img class='question__img' src='img/31proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 55,
    question: "В чем разница между ES6 class и ES5 function constructor?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Классы, добавленные в стандарте EcmaScript 6, всего лишь синтаксический сахар поверх всем известных прототипов.</p> <p> В работе эти подходы отличаются уровнем абстракции, который ожидаемо выше у классов - разработчику не приходится напрямую работать с прототипами.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 56,
    question: "Как проверить, из какого класса был создан объект?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Для этого в JavaScript используется оператор <span>instanceof</span>. Он позволяет проверить, из какого класса был создан объект, учитывая наследование.</p> <p>Например, есть базовый класс Animal и классы-наследники Dog и Cat:</p> <p><img class='question__img' src='img/40.1proglibPart2.png' alt=''></p> <p>Создадим объект класса Dog и проверим с помощью оператора instanceof, является ли объект экземпляром указанного класса или классов-родителей:</p> <p><img class='question__img' src='img/40.2proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 57,
    question:
      "В чем разница между Array.prototype.forEach и Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Array.prototype.forEach - это инструмент обхода цикла процедурно, а Array.prototype.map - функционально.</p> <p>.forEach просто проходится по массиву с выполнением переданного обратного вызова на каждой итерации, а .map создает и возвращает новый массив на основе исходного, выкладывая по кирпичику на каждой итерации.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 58,
    question: "Как бы Вы реализовали метод Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#34",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Метод map</span> создает новый массив с результатом вызова указанной функции для каждого элемента массива</p> <p><span>Метод map</span> вызывает переданную функцию <span>callback</span> один раз для каждого элемента, в порядке их появления и конструирует новый массив из результатов её вызова</p> <ul> Функция <span>callback</span> вызывается с тремя аргументами: <li>- значение элемента,</li> <li>- индекс элемента,</li> <li>- массив, по которому осуществляется проход.</li> </ul> <p>Следующий код берёт массив чисел и создаёт новый массив, содержащий квадратные корни чисел из первого массива.</p> <p><span>const numbers = [1, 4, 9];<br>const roots = numbers.map(Math.sqrt);<br>// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]</span></p> <p>Следующий код показывает, как работает отображение, когда функция требует один аргумент. Аргумент будет автоматически присваиваться каждому элементу массива, когда map проходит по оригинальному массиву.</p> <p><span>const numbers = [1, 4, 9];<br>const doubles = numbers.map((num) => num * 2);<br>// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 59,
    question: "Как бы Вы реализовали метод Array.prototype.filter?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#35",
      linkName: "answer on habr.com",
      answer1:
        "<p>Метод<span>filter() создаёт новый массив со всеми элементами</span>, прошедшими проверку, задаваемую в передаваемой функции.</p> <p><span>Метод filter()</span>вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, и создаёт новый массив со всеми значениями, для которых функция callback вернула значение, которое может быть приведено к true.</p> <ul> Функция <span>callback</span> вызывается с тремя аргументами: <li>- значение элемента,</li> <li>- индекс элемента,</li> <li>- массив, по которому осуществляется проход.</li> </ul> <p>Следующий пример использует <span>filter()</span> для создания отфильтрованного массива, все элементы которого больше или равны 10, а все меньшие 10 удалены.</p> <p><img class='question__img' src='img/habr70/35habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 60,
    question: "Как бы Вы реализовали метод Array.prototype.reduce?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#36",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Метод reduce</span> применяет функцию <span>reducer</span> к каждому элементу массива (слева-направо), возвращая одно результирующее значение.</p> <p>Подробнее смотри <a class='question__link' href='https://habr.com/ru/articles/486820/' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 61,
    question: "Что такое объект arguments?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#37",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Arguments</span>— это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции.</p> <p>Преобразовать <span>arguments</span> в массив можно с помощью <span>Array.prototype.slice</span>: <br> <span>Array.prototype.slice.call(arguments)</span>.</p> <p><span>Запомните</span>: в стрелочных функциях объект arguments не работает.</p> <p><img class='question__img' src='img/habr70/37habr70.png' alt=''></p> <p>Вызов функции four приводит к ошибке <span>ReferenceError: arguments is not defined.</span> Эту проблему можно решить с помощью оператора <span>rest</span>:</p> <p><span>const four = (...args) => args</span></p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
];

export { questionsJS };
