const questionsJSHabr = [
  /* https://habr.com/ru/articles/486820/ */

  {
    id: 1,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#1",
      linkName: "answer on habr.com",
      answer1:
        "Для начала давайте поговорим о том, что у них общего.Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS (Number, String, Boolean, Symbol, undefined, null, BigInt). Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора '!!' является false.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },

  {
    id: 2,
    question: "Для чего используется оператор ' && ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#2",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '&&' (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: console.log(false && 1 && []) // false, console.log(' ' && true && 5) // 5. При этом второй операнд не вычисляется.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Для чего используется оператор ' || ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#3",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '||' (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question:
      "Является ли использование унарного плюса (оператор ' + ') самым быстрым способом преобразования строки в число?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#4",
      linkName: "answer on habr.com",
      answer1:
        "Согласно MDN оператор " +
        " действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Что такое DOM?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#5",
      linkName: "answer on habr.com",
      answer1:
        "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.",
      image1: "",
      href2: "https://learn.javascript.ru/dom-nodes",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Основой HTML-документа являются теги.В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Что такое распространение события (Event Propogation)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#6",
      linkName: "answer on habr.com",
      answer1:
        "Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы: 1. Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков. 2. Целевая фаза — это когда событие достигает целевого элемента. 3. Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое всплытие события (Event Bubbling)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#7",
      linkName: "answer on habr.com",
      answer1:
        "Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. Поэтому если кликнуть на <p>, то мы увидим три оповещения: p → div → form.Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде. Почти все события всплывают. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают. Всегда можно узнать, на каком конкретно элементе произошло событие. Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target. Отличия от this (=event.currentTarget): 1. event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен. 2. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик. Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Что такое погружение события (Event Capturing)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#8",
      linkName: "answer on habr.com",
      answer1:
        "Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков. У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения. Если мы кликнем по элементу child, то увидим в консоли следующее: window, document, html, grandparent, parent, child. Это и есть погружение события.",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной. То есть при клике на <td> событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики. Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах. Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так: elem.addEventListener(..., {capture: true}) Существуют два варианта значений опции capture: Если аргумент false (по умолчанию), то событие будет поймано при всплытии. Если аргумент true, то событие будет перехвачено при погружении.  Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение. ",
      image2: "",
    },
  },
  {
    id: 9,
    question:
      "В чем разница между методами event.preventDefault() и event.stopPropagation()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#9",
      linkName: "answer on habr.com",
      answer1:
        "Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для этого нужно вызвать метод event.stopPropagation(). Event.preventDefault() Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п. Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события. Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.",
      image2: "",
      href3: "https://doka.guide/js/event-prevent-default/",
      linkName3: "DOKA.GUIDE",
      answer3:
        "Методы event.preventDefault() и event.stopPropagation() предназначены для решения похожих задач и часто используются вместе. Метод event.stopPropagation() останавливает распространение события (event propagation). Распространение события включает стадию захвата и стадию всплытия. Например, рассмотрим обработку события на стадии захвата — при распространении события от родительских элементов к дочерним. Обработчик, объявленный в дочернем элементе, не будет вызван после выполнения stopPropagation() в обработчике родительского элемента. При этом действие по умолчанию не отменится. Метод event.preventDefault() отменяет действие по умолчанию. Например, переход по ссылке при клике на элемент <a>. Само событие продолжает распространяться после выполнения preventDefault().",
      image3: "",
    },
  },
  {
    id: 10,
    question: "Как узнать об использовании метода event.preventDefault()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#10",
      linkName: "answer on habr.com",
      answer1:
        "Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Почему obj.someprop.x приводит к ошибке?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#11",
      linkName: "answer on habr.com",
      answer1:
        "const obj = {} console.log(obj.someprop.x) Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Что такое цель события или целевой элемент (event.target)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#12",
      linkName: "answer on habr.com",
      answer1:
        "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Что такое текущая цель события (event.currentTarget)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#13",
      linkName: "answer on habr.com",
      answer1:
        "Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "В чем разница между операторами ' == ' и ')' === ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#14",
      linkName: "answer on habr.com",
      answer1:
        ("Разница между оператором " ==
          " (абстрактное или нестрогое равенство) и оператором ") ===
        " (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question:
      "Почему результатом сравнения двух похожих объектов является false?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#15",
      linkName: "answer on habr.com",
      answer1:
        "let a = {a: 1} let b = {a: 1} let c = a console.log(a === b) // false console.log(a === c) // true хм... В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Для чего используется оператор '!!'?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#16",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '!!' (двойное отрицание) приводит значение справа от него к логическому значению. console.log(!!null) // false, console.log(!!undefined) // false, console.log(!![])  //true, console.log(!!1)  //true",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Как записать несколько выражений в одну строку?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#17",
      linkName: "answer on habr.com",
      answer1:
        "Для этого мы можем использовать оператор ',' (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Что такое поднятие (Hoisting)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#18",
      linkName: "answer on habr.com",
      answer1:
        "Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости. Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения. Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение. Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.). Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются. Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются. После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Glossary/Hoisting",
      linkName2: "mdn web docs_",
      answer2:
        "Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. Однако, hoisting может привести и к недоразумениям. Например, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что такое область видимости (Scope)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#19",
      linkName: "answer on habr.com",
      answer1:
        "Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде. Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции. Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него. Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).",
      image1: "",
      href2: "https://doka.guide/js/closures/",
      linkName2: "DOKA.GUIDE",
      answer2:
        "Не все переменные одинаково доступны — всё зависит от того, в каком месте кода их объявили. Разбираемся, почему так. Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют области видимости. Область видимости — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом. Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка. Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки. Глобальная область видимости — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости. Переменные в глобальной области видимости называются глобальными переменными и доступны всем. Самый известный пример глобальной переменной — это console. JS в браузерах так устроен, что глобальные переменные попадают в объект window. Если очень грубо, то можно сказать, что window в случае браузера — это и есть глобальная область видимости. Модульная область видимости - при использовании ES-модулей переменная, объявляемая вне функций, будет доступна, но только в том же модуле, где она создана. Чтобы предоставить доступ к определённым данным модуля, их нужно экспортировать. Разделение на модули упрощает задачу структурирования кода. Это особенно важно для больших проектов. Блочная область видимости ограничена программным блоком, обозначенным при помощи { и }. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости. Функциональная область видимости — это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции. Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Что такое замыкание (Closures)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#20",
      linkName: "answer on habr.com",
      answer1:
        "Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание. По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures",
      linkName2: "mdn web docs",
      answer2:
        "Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.",
      image2: "",
    },
  },
  {
    id: 21,
    question: "Какие значения в JS являются ложными?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#21",
      linkName: "answer on habr.com",
      answer1:
        "const falsyValues = ['', 0, null, undefined, NaN, false] Ложными являются значения, результатом преобразования которых в логическое значение является false.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "Как проверить, является ли значение ложным?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#22",
      linkName: "answer on habr.com",
      answer1:
        "Следует использовать функцию Boolean или оператор '!!' (двойное отрицание).",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "Для чего используется директива «use strict»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#23",
      linkName: "answer on habr.com",
      answer1:
        "«use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах. Вот какие ограничения накладывает строгий режим: 1. Нельзя присваивать значения или обращаться к необъявленным переменным 2. Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи 3. Нельзя удалить «неудаляемое» свойство объекта 4. Запрещено дублирование параметров 5. Нельзя создавать функции с помощью функции eval 6. Значением «this» по умолчанию является undefined",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question: "Какое значение имеет this?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#24",
      linkName: "answer on habr.com",
      answer1:
        "Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "Что такое прототип объекта?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#25",
      linkName: "answer on habr.com",
      answer1:
        "В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.  Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype.",
      image1: "",
      href2: "https://learn.javascript.ru/prototype-inheritance",
      linkName2: "современный учебник по JavaScript",
      answer2:
        "В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип». Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Операция записи не использует прототип. Прототип используется только для чтения свойств.",
      image2: "",
    },
  },
  {
    id: 26,
    question: "Что такое IIFE?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#26",
      linkName: "answer on habr.com",
      answer1:
        "IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function( ) { }( )), (function( ) { })( ) ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question: "Для чего используется метод Function.prototype.apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#27",
      linkName: "answer on habr.com",
      answer1:
        "Apply используется для привязки определенного объекта к значению this вызываемой функции. const details = { message: 'Hello World!'} function getMessage() {return this.message} getMessage.apply(details) // Hello World!  Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива. const person = { name: 'Marko Polo' function greeting(greetingMessage) {    return `${greetingMessage} ${this.name}` //greeting.apply(person, ['Hello']) // Hello Marko Polo",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "Для чего используется метод Function.prototype.call?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#28",
      linkName: "answer on habr.com",
      answer1:
        "Call используется для привязки определенного объекта к значению this вызываемой функции. Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую. greeting.call(person, 'Hello'); // Hello Marko Polo ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question: "В чем разница между методами call и apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#29",
      linkName: "answer on habr.com",
      answer1:
        "Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую. reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15 reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15 ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question: "Для чего используется метод Function.prototype.bind?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#30",
      linkName: "answer on habr.com",
      answer1:
        "Bind возвращает новую функцию, значением this которой является объект, указанный в к0честве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию. ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "REACT?",
      image2: "",
    },
  },
  {
    id: 31,
    question:
      "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#31",
      linkName: "answer on habr.com",
      answer1:
        "Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются. Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования. Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива: const words = ['Functional', 'Procedural', 'Object-Oriented'] const wordsLength = words.map(word => word.length). Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback: const data = { { name: 'Mark', isRegistered: true } { name: 'Mary', isRegistered: false } { name: 'Mae', isRegistered: true}}. Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив: const strs = ['I', ' ', 'am', ' ', 'Iron', ' ', 'Man'] const result = strs.reduce((acc, currentStr) => acc + str, '')",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "REACT?",
      image2: "",
    },
  },
  {
    id: 32,
    question: "Что такое функции высшего порядка (Higher Order Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#32",
      linkName: "answer on habr.com",
      answer1:
        "Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента. function higherOrderFunction(param, callback) { return callback(param) }",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 33,
    question:
      "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#33",
      linkName: "answer on habr.com",
      answer1:
        "Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 34,
    question: "Как бы Вы реализовали метод Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#34",
      linkName: "answer on habr.com",
      answer1:
        "Метод map создает новый массив с результатом вызова указанной функции для каждого элемента массива",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },

  {
    id: 35,
    question: "Как бы Вы реализовали метод Array.prototype.filter?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#35",
      linkName: "answer on habr.com",
      answer1:
        "Метод filter создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 36,
    question: "Как бы Вы реализовали метод Array.prototype.reduce?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#36",
      linkName: "answer on habr.com",
      answer1:
        "Метод reduce применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 37,
    question: "Что такое объект arguments?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#37",
      linkName: "answer on habr.com",
      answer1:
        "Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции. Преобразовать arguments в массив можно с помощью Array.prototype.slice: Array.prototype.slice.call(arguments). Запомните: в стрелочных функциях объект arguments не работает. function one() {     return arguments };  const two = function() {     return arguments }; const three = function three({  return arguments }); const four = () => arguments four() // arguments is not defined. Вызов функции four приводит к ошибке ReferenceError: arguments is not defined. Эту проблему можно решить с помощью оператора rest: const four = (...args) => args; Это автоматически поместит все параметры в массив.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 38,
    question: "Как создать объект, не имеющий прототипа?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#38",
      linkName: "answer on habr.com",
      answer1: "Это можно сделать с помощью Object.create",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 39,
    question:
      "Почему в представленном коде переменная b становится глобальной при вызове функции?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#39",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 40,
    question: "Что такое ECMAScript?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#40",
      linkName: "answer on habr.com",
      answer1:
        "ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.Последний вариант спецификации ECMA-262",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 41,
    question: "Что нового привнес в JS стандарт ES6 или ECMAScript2015?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#41",
      linkName: "answer on habr.com",
      answer1:
        "Стрелочные функции (Arrow Functions). Классы (Classes). Шаблонные строки (Template Strings). Расширенные объектные литералы (Enhanced Object literals). Деструктуризация (Object Destructuring). Промисы (Promises). Генераторы (Generators). Модули (Modules). Symbol. Прокси (Proxies). Множества (Sets). Параметры по умолчанию. Операторы rest и spread. Блочная область видимости (ключевые слова «let» и «const»).",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 42,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Это означает, что они доступны из любого места в коде. Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }). Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную).",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 43,
    question: "Что такое стрелочные функции (Arrow Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#43",
      linkName: "answer on habr.com",
      answer1:
        "Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»: const getCurrentDate = () => new Date(). В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение. Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки: const getArgs = () => arguments, const getArgs2 = (...rest) => rest. У стрелочных функций нет доступа к объекту arguments. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор rest. ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 44,
    question: "Что такое классы (Classes)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#44",
      linkName: "answer on habr.com",
      answer1:
        "Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 45,
    question: "Что такое шаблонные литералы (Template Literals)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#45",
      linkName: "answer on habr.com",
      answer1:
        "Шаблонные литералы — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``)",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 46,
    question: "Что такое деструктуризация объекта (Object Destructuring)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#46",
      linkName: "answer on habr.com",
      answer1:
        "Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива. Допустим, у нас есть такой объект: const employee = {   firstName: 'Marko', lastName: 'Polo', position: 'Software Developer', yearHired: 2017}. Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки ({ }), а если речь идет о массиве — в квадратные скобки ([ ]): let { firstName, lastName, position, yearHired } = employee. Для изменения имени переменной следует использовать «propertyName: newName»: let { firstName: fName, lastName: lName, position, yearHired } = employee. Для присвоения переменным значения по умолчанию следует использовать «propertyName = 'defaultValue'»: let { firstName = 'Mark', lastName: lName, position, yearHired } = employee",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 47,
    question: "Что такое модули (Modules)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#47",
      linkName: "answer on habr.com",
      answer1:
        "Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода: 1. CommonJS — Nodejs 2. AMD (AsyncronousModuleDefinition) — Browsers. Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта. Экспорт функциональности в другой файл (именной экспорт)",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 48,
    question: "Что такое объект Set?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#48",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 49,
    question: "Что такое функция обратного вызова (Callback Function)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#49",
      linkName: "answer on habr.com",
      answer1:
        "Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 50,
    question: "Что такое промисы (Promises)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#50",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 51,
    question: "Что такое async/await?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#51",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 52,
    question: "В чем разница между spread-оператором и rest-оператором?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#52",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 53,
    question: "Что такое параметры по умолчанию (Default Parameters)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#53",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 54,
    question: "Что такое объектная обертка (Wrapper Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#54",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 55,
    question:
      "В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#55",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 56,
    question: "Что такое NaN? Как проверить, является ли значение NaN?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#56",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 57,
    question: "Как проверить, является ли значение массивом?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#57",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 58,
    question:
      "Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора ' % ')?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#58",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 59,
    question: "Как определить наличие свойства в объекте?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#59",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 60,
    question: "Что такое AJAX?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#60",
      linkName: "answer on habr.com",
      answer1:
        "AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы. AJAX использует следующие технологии: HTML — структура веб-страницы. CSS — стили веб-страницы. JavaScript — поведение страницы и работа с DOM. XMLHttpRequest API — отправка и получение данных с сервера. PHP, Python, Nodejs — какой-нибудь серверный язык.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 61,
    question: "Как в JS создать объект?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#61",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 62,
    question: "В чем разница между методами Object.freeze и Object.seal?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#62",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 63,
    question: "В чем разница между оператором «in» и методом hasOwnProperty?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#63",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 64,
    question: "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#64",
      linkName: "answer on habr.com",
      answer1:
        "Функции обратного вызова (Callbacks). Промисы (Promises). Async/await. Библиотеки вроде async.js, blueprint, q, co.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 65,
    question:
      "В чем разница между обычной функцией и функциональным выражением?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#65",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 66,
    question: "Как в JS вызвать функцию?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#66",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 67,
    question: "Что такое запоминание или мемоизация (Memoization)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#67",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 68,
    question: "Как бы Вы реализовали вспомогательную функцию запоминания?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#68",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 69,
    question:
      "Почему typeof null возвращает object? Как проверить, является ли значение null?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#69",
      linkName: "answer on habr.com",
      answer1:
        "typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок)",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 70,
    question: "Для чего используется ключевое слово «new»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#70",
      linkName: "answer on habr.com",
      answer1:
        "Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса). Ключевое слово «new» делает 4 вещи: Создает пустой объект. Привязывает к нему значение this. Функция наследует от functionName.prototype. Возвращает значение this, если не указано иное.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },

  /* ----------------------------- */

  // {
  //   id: 1,
  //   question: "",
  //   answer: {
  //     href: "",
  //     linkName: "",
  //     answer1: "",
  //     image1: "",
  //     href2: "",
  //     linkName2: "",
  //     answer2: "",
  //     image2: "",
  //   },
  // },
];

const questionsJSProglib = [
  /* https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18 */
  {
    id: 1,
    question: "Какие типы данных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Number – число. Тип Number в JavaScript может хранить как целые числа, так и числа с плавающей точкой. BigInt – используется для представления целых чисел произвольной длины, превышающих 2^53 – 1. BigInt создается с помощью добавления n в конец целочисленного литерала или путем вызова функции BigInt(), которая создает BigInt из строк, чисел и т.д String – строка (последовательность символов), например, 'JavaScript – главный язык интернета'.Строки записываются с использованием кавычек, можно использовать одинарные или двойные кавычки.Boolean – логический (булев) тип, который может принимать значения true (истина) или false (ложь). Object – объект. Это значение в памяти, на которое возможно сослаться с помощью идентификатора. Объект может расцениваться как набор свойств. Значения свойств могут иметь любой тип, включая другие объекты, что позволяет строить сложные, разветвленные иерархии данных. Null – специальное значение, которое представляет «ничего», «пусто», или «неизвестное значение». Undefined – это значение присваивается переменной, если она была объявлена, но не получила значения. Symbol – это уникальный и неизменяемый тип данных, который можно использовать в качестве идентификатора для свойств объекта.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "В чем состоит различие между == и ===?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript операторы == и === используются для сравнения двух значений, но они работают по-разному: == проверяет на абстрактное равенство, то есть он преобразует типы данных перед сравнением – например, если вы сравниваете строку с числом, JavaScript преобразует строку в число перед сравнением. Если строка не может быть преобразована в число, она преобразуется в NaN, что возвращает false. Если оба операнда имеют разные типы данных, но они могут быть преобразованы в один и тот же тип данных и имеют одно и то же значение, оператор == вернет true. Оператор === проверяет на строгое равенство, то есть он не выполняет преобразование типов данных. Если два значения имеют разные типы данных, оператор === вернет false, даже если они имеют одно и то же значение. Если оба операнда имеют одинаковый тип данных и одинаковое значение, оператор=== вернетtrue",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Какие способы объявления переменных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript есть четыре способа объявления переменных: 1. myVariable = 5; – неявное объявление переменной. Оно создает глобальную переменную myVariable и присваивает ей значение 5, что может привести к ошибкам в строгом режиме. 2. var myVariable = 5; – явное объявление переменной с использованием ключевого слова var. Область видимости переменной myVariable может быть функциональной или глобальной, если она объявлена вне функции. Недостаток var состоит в том, что ее область видимости не ограничивается блоком, в котором используется переменная. 3. let myVariable = 5;– явное объявление переменной с использованием ключевого слова let. Область видимости такой переменной ограничивается блоком, в котором она объявлена – на уровне функции она не видна 4.const myVariable = 5; – это явное объявление переменной с использованием ключевого слова const. Переменная myVariable объявляется в области видимости блока, как и let. Однако, в отличие отlet, переменная myVariable является неизменяемой – ее значение не может быть изменено после объявления, за одним исключением: если значение является объектом или массивом, его свойства или элементы могут быть изменены, но сама переменная все равно остается неизменяемой",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript и null, и undefined представляют отсутствие значения, но они используются в разных контекстах и имеют разные семантические значения. Undefined – присваивается переменной, когда она объявлена, но ей не присвоено конкретное значение. Null – специальное значение, которое представляет «ничего», «пусто» или «неизвестное значение». Присваивается переменной вручную, чтобы указать, что она не должна иметь значения. Например, если нужно очистить значение переменной, можно установить его в null",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Чем стрелочные функции отличаются от обычных?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Стрелочные функции позволяют использовать упрощенный синтаксис при создании небольших функций-обработчиков. У них есть некоторые ограничения по сравнению с обычными функциями: Стрелочные функции не могут использовать объект arguments. В обычных функциях этот объект содержит все переданные при вызове аргументы. У стрелочных функций другой синтаксис записи. Они записываются короче, используя стрелку => и не требуя ключевого слова function. У стрелочных функций нет собственного контекста this. Вместо этого контекст берется из внешней области видимости. Стрелочные функции нельзя использовать как конструкторы с ключевым словом new. То есть, из них нельзя создавать объекты при помощи оператора new",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Что такое замыкание?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Замыкание (closure) в JavaScript – это комбинация функции и лексического окружения, в котором эта функция была определена. Такая функция имеет доступ к переменным внешней функции, даже после того, как внешняя функция завершила выполнение",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое шаблонные строки (литералы)?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Шаблонные строки (template literals) в JavaScript – это новый способ работы со строками, введенный в ECMAScript 6 (ES6). Они обозначаются обратными кавычками ` вместо одинарных или двойных кавычек. Шаблонные строки позволяют создавать многострочные строки без необходимости использования специальных символов или конкатенации строк. Шаблонные строки также поддерживают интерполяцию строк, что позволяет вставлять выражения прямо в строку. Эти выражения заключаются в фигурные скобки ${expression} и вычисляются при создании строки",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Что такое Map и Set в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Map и Set – это два типа коллекций, которые были введены в ECMAScript 6 (ES6). Они предоставляют более гибкие и мощные способы работы с наборами данных по сравнению с обычными объектами и массивами. Map – это коллекция, которая состоит из пар ключ-значение, подобно объектам. Основное отличие Map от объектов заключается в том, что Map запоминает порядок добавления пар и позволяет использовать в качестве ключей данные любых типов. При желании в Map в качестве ключей можно использовать функции. Set – это множество, в котором каждое значение может появляться только один раз. Дубликатов в Set нет.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Как проверить наличие свойства в объекте?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript есть два основных способа проверить наличие свойства в объекте – метод hasOwnProperty и оператор in. Метод hasOwnProperty()возвращает true, если указанное свойство является прямым свойством объекта, и false в противном случае. Этот метод не проверяет свойства в цепочке прототипов объекта. Оператор in возвращает true, если указанное свойство существует в объекте, независимо от того, является ли оно собственным свойством или унаследовано.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Как получить доступ к свойствам объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript есть два основных способа доступа к свойствам объекта: статический (с использованием точечной нотации) и динамический (с использованием квадратных скобок).Точечная нотация позволяет напрямую получить доступ к свойству объекта, используя имя свойства. Скобочная нотация позволяет динамически получить доступ к свойству объекта с использованием квадратных скобок. Скобочная нотация использует интерполяцию и особенно полезна, если имя свойства неизвестно заранее или когда оно хранится в переменной",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Какие основные методы работы с массивами есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Oсновные методы для работы с массивами – forEach, filter, map и reduce. МетодforEach выполняет функцию для каждого элемента в массиве. Он не возвращает ничего, но позволяет выполнять действия с каждым элементом массива. Применяется, когда нужно выполнить некоторые операции над каждым элементом, но не нужно создавать новый массив. Метод filter создает новый массив, включающий только те элементы исходного массива, для которых функция обратного вызова возвращает true. Используется, когда нужно отфильтровать массив, чтобы включить только определенные элементы. Метод mapсоздает новый массив, который состоит из результатов применения функции к каждому элементу исходного массива. Применяется, когда нужно преобразовать каждый элемент массива. Метод reduce выполняет функцию для каждого элемента массива, накапливая результат в одном значении. Используется, когда нужно объединить все элементы массива в одно значение, например, вычислить сумму всех чисел в массиве",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Какие способы создания объектов есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Объекты JavaScript создаются с помощью функции-конструктора, литеральной нотации объекта, класса и метода Object.create().Функция-конструктор – это специальная функция, которую можно использовать для создания объектов с определенными свойствами и методами. Функция-конструктор используется с ключевым словом new. Литеральная нотация объекта позволяет создать объект, указав его свойства и значения внутри фигурных скобок {}. Классы позволяют создавать объекты с помощью синтаксиса, похожего на классы в других языках программирования. Метод Object.create() позволяет создать новый объект, используя существующий объект в качестве прототипа для нового объекта. Этот метод принимает два аргумента: прототип и объект свойств. Объект свойств определяет свойства нового объекта и их атрибуты configurable, enumerable, writable и value.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Что такое Promise (промис)?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода. Он имеет три состояния: 1. pending – начальное состояние, означает, что асинхронная операция еще не завершена. 2. fulfilled – операция успешно завершена. 3. rejected – операция завершена с ошибкой. Промисы создаются с помощью конструктора new Promise(). Этот конструктор принимает в качестве аргумента функцию, которая выполняет асинхронную операцию. Функция принимает два аргумента resolve и reject, которые используются для изменения состояния промиса. Если асинхронная операция завершена успешно, вызывается resolve, если произошла ошибка, вызывается reject. Промисы позволяют обрабатывать результаты асинхронных операций, используя методы .then() и .catch(). Метод.then() принимает два аргумента: функцию обратного вызова, которая будет вызвана при успешном выполнении промиса, и функцию обратного вызова, которая будет вызвана при ошибке. Метод.catch() используется для обработки ошибок, которые могут произойти при выполнении промиса. Промисы можно связывать в цепочки, что позволяет выполнять несколько асинхронных операций последовательно. Для этого результат каждого промиса передается в следующий промис в цепочке. Это делается с помощью метода .then(). Промисы также могут быть использованы для создания асинхронных операций, которые зависят от других операци",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "Что такое async/await и как они используются?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Async/await – это синтаксис JavaScript, который облегчает работу с промисами. Ключевое слово async перед функцией означает, что функция всегда возвращает промис. Ключевое слово awaitиспользуется внутри асинхронных функций и заставляет JavaScript ожидать, пока промис не будет выполнен, прежде чем продолжить выполнение кода. Надо отметить, что await нельзя использовать вне асинхронной функции. Например, этот код приведет к ошибке. Чтобы решить эту проблему, можно обернуть вызов в другую асинхронную функцию",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "Как проверить, является ли объект массивом?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Для такой проверки можно использовать встроенный методArray.isArray(). Этот метод принимает объект в качестве аргумента и возвращает true, если объект является массивом, и falseв противном случае",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Что делает оператор расширения?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Оператор расширения ... разворачивает итерируемые элементы в отдельные элементы, что удобно для передачи аргументов, объединения массивов/объектов и добавления новых свойств в объекты. Используется: 1. В функциях, где ожидаемое количество аргументов для вызова равно нулю или более 2. В литералах массива 3. В литералах объекта, где количество пар ключ-значение должно быть равно нулю или более 4. Для преобразования строки в массив символов 5. Для преобразования числа в массив цифр и наоборот 6. Для копирования объектов",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Как выполняется клонирование объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Если объект не содержит вложенных объектов, как в приведенном ниже примере, для клонирования можно использовать оператор расширения...или метод Object.assign(). Если объект содержит вложенные объекты, нужно выполнить глубокое копирование. Относительно медленный вариант – с использованием JSON. Другой вариант – с использованием метода cloneDeep из библиотеки lodash.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Как изменить контекст функции?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Изменить контекст функции можно с помощью методов bind(),call() и apply(). Метод bind() возвращает новую функцию с привязанным контекстом. Метод call() принимает последовательность аргументов, а apply() принимает массив аргументов в качестве второго параметра",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что такое тернарный оператор и как он работает?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Тернарный оператор – это сокращенная форма записи if-else. Он называется тернарным, потому что является единственным оператором в JavaScript, который принимает три аргумента. Синтаксис тернарного оператора: условие ? выражение_если_истинно : выражение_если_ложно. Условие – любое условие, которое возвращает true или false. Выражение для истинного условия – что нужно вернуть, если условие истинно. Выражение для ложного условия – что нужно вернуть, если условие ложно.",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Что такое деструктуризация?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Деструктуризация в JavaScript позволяет извлечь данные из массива или свойства объекта и присвоить их отдельным переменным. Деструктуризация удобна тем, что позволяет не писать лишний код для доступа к данным внутри объектов/массивов по индексам или ключам.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

const questionsJSHabr35 = [
  {
    id: 1,
    question:
      "В чем смысл оборачивания всего содержимого JavaScript-файла в функцию?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "Этот шаблон называется IIFE - Immediately Invoked Function Expression (немедленно вызываемое функциональное выражение). Этот подход позволяет: Этот шаблон называется IIFE - Immediately Invoked Function Expression (немедленно вызываемое функциональное выражение). Этот подход позволяет: обеспечить коду собственный блок видимости, то-есть контекст выполнения, избежать загрязнения глобальной области видимости глобальными переменными, избежать неумышленного переопределения уже существующих переменных в глобальной области видимости, обеспечить коду собственный блок видимости, то-есть контекст выполнения, избежать загрязнения глобальной области видимости глобальными переменными, избежать неумышленного переопределения уже существующих переменных в глобальной области видимости",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "В чем смысл и польза указания use strict в начале JavaScript-файла?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Что такое NaN? Какого типа это значение? Как можно узнать, равно ли значение переменной NaN?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "NaN расшифровывается как 'Not A Number', это 'falsey' (ложное) значение. Выражение typeof NaN возвращает тип Number. Проверить значение переменной на соответствие NaN можно, воспользовавшись встроенным методом isNaN() или используя оператор тройного равенства ===.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "Что такое замыкание в JavaScript? Приведите пример.",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Замыкание в JavaScript - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем. В следующем примере мы определяем функцию makeCounter(), которая фактически является фабричной функцией. При вызове она возвращает дочернюю функцию, которая имеет доступ к лексическому окружению внешней функции, то-есть функции makeCounter(). Таким образом, возвращаемая функция запоминает переменную counter и в последующем изменяет ее значение. function makeCounter(initial = 0) { let counter = initial;   return function() { return counter += 1;}} const counterA = makeCounter(0); console.log(counterA()); // 1 console.log(counterA()); // 2 const counterB = makeCounter(100); console.log(counterB()); // 101 console.log(counterB()); // 102",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Как можно клонировать объект?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Можно использовать оператор остатка .... Можно использовать Object.assign(newObj, oldObj). Но эти подходы не позволяют выполнить глубокое клонирование. Поэтому, если нам нужно клонировать объект со вложенными объектами, мы можем использовать либо метод какой-либо библиотеки (привет, lodash), либо сделать это средствами встроенного объекта JSON. JSON.parse(JSON.stringify(objectToClone))",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Как можно добавить элемент в начало и в конец массива?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Чтобы добавить элемент в начало массива, можно использовать Array.prototype.unshift(). Для добавления элемента в конец массива подойдет Array.prototype.push().",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "В чем разница между undefined и is not defined?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "undefined - это значение, присваемое объявленной, но не проинициализированной переменной. Мы получаем undefined, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку is not defined",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Как проверить, является ли объект массивом?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Для этого можно использовать встроенный метод Array.isArray().",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Что такое hoisting (поднятие) в JavaScript?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости. Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений. По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Что такое this?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "this указывает на объект области видимости во время выполнения. По умолчанию this указывает на глобальный объект. В браузере выражение this === window будет истинно.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Как работает прототипное наследование?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Если отвечать кратко, в JavaScript все является объектами. Эти объекты связаны цепочками прототипов, по которым им передаются методы и свойства. При обращении к свойству или методу объекта сначала происходит поиск этого свойства у самого объекта. В случае неудачи поиск перенаправляется в его прототип, затем в прототип прототипа и так далее, пока искомое свойство не будет найдено, либо пока не закончится цепочка прототипов.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Объясните, почему запись function foo(){}() вызывает ошибку и не работает, как IIFE?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Здесь дело в том, что круглые скобки вызова функции добавлены сразу после Function Declaration. Однако, они могут следовать только за выражением (expression). Поэтому мы должны либо прибегнуть к варианту с Function Expression, либо обернуть Function Declaration в скобки, тем самым превратив его в выражение. const foo = function(){}() // либо (function foo(){})() // либо со стрелочной функцией (() => {})()",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "В чем разница между null, undefined и undeclared?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "null - это в прямом смысле 'ничего'. Можно использовать это значение в качестве плейсхолдера. undefined - это значение для случая 'объявлено, но не инициализировано'. undeclared - это ошибка, возникающая в случае обращении к необъявленной переменной.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "В чем разница между Array.prototype.forEach и Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Array.prototype.forEach - это инструмент обхода цикла процедурно, а Array.prototype.map - функционально. .forEach просто проходится по массиву с выполнением переданного обратного вызова на каждой итерации, а .map создает и возвращает новый массив на основе исходного, выкладывая по кирпичику на каждой итерации.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "В каких случаях используются анонимные функции?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Анонимные функции чаще всего используются в качестве функций обратных вызовов. Также, каждая стрелочная функция является анонимной",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Объясните разницу между const person = Person() и const person = new Person() при function Person(){}",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Если функция Person() не возвращает явным образом создаваемый экземпляр, то вариант const person = Person() присвоит константе person значение undefined, поскольку именно таков результат void функции. Если функция Person явным образом возвращает экземпляр, он станет значением константы person при const person = Person(). Однако, вариант с использование оператора new 'выигрывает', поскольку он устанавливает корректную связь объекта person с цепочкой прототипов Person, в то время как выражение const person = Person() просто присваивает константе результат вызова функции.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "В чем разница между Function.prototype.call и Function.prototype.apply?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "В чем разница между Function.prototype.call и Function.prototype.apply?",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Как работает Function.prototype.bind?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Данный метод возвращает функцию, по отношению к которой он вызывается, но с подмененным контекстом.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что вы знаете об AJAX?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "AJAX = Asynchronous Javascript And XML. Это подход к асинхронному (неблокирующему) обмену данными с сервером. Изначально для решения подобной задачи использовался объект XMLHttpRequest , сейчас же более актуален дружелюбный к обещаниям (Promise) fetch API.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "В чем разница между атрибутами и свойствами?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Атрибут - это HTML-термин, в то время как свойство - термин из JavaScript. Иными словами, если речь идет о значении в HTML-разметке, мы говорим об атрибуте. Однако, если имеется в виду свойство объекта, к которому мы получили доступ средствами JavaScript - вернее называть это свойством.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 21,
    question: "В чем разница между == и ===?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Оператор двойного равенства производит приведение типов, оператор строгого равенства - нет.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "Почему лучше оставлять глобальную область видимости 'как есть' и не трогать ее?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "По той причине, что свойства глобальной области видимости может изменить любой JavaScript-код, имеющий к ней доступ. Также, это грозит конфликтами имен.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "Что такое SPA и как сделать его SEO-friendly?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Single Page Application - это реализация веб-приложения таким образом, чтобы при первой загрузке пользователь получал все ресурсы, необходимые для того, чтобы избавиться от загрузки страницы с нуля при совершении интерактивных действий с интерфейсом. Основную роль в SPA играет JavaScript, реализующий механизмы динамического обновления данных без перезагрузки страницы. Для того, чтобы сделать SPA SEO-friendly, можно обратиться к таким решениям, как предварительный рендеринг или серверный рендеринг.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question: "Какие преимущества и недостатки у использования Promise API вместо обратных вызовов?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Обещания избавляют разработчиков от ада обратных вызовов, но это не единственное их достоинство. Важно также отметить, что пользуясь обратными вызовами, мы зачастую были вынуждены 'верить' стороннему коду. А вызовет ли он наш коллбэк? А вызовет ли он его корректное количество раз? А не вызовет ли он его слишком рано или слишком поздно? Представьте, что функция, снимающая деньги со счета пользователя, передается коллбэком в сторонний (в той или иной степени) код. Что будет, если он вследствие внесенных со стороны изменений начнет вести себя некорректно и, скажем, начнет вызывать эту функцию пять раз вместо одного? Используя обещания, мы сами властны над нашим кодом. Мы сначала дожидаемся результата вызова сторонней функции, возвращающей обещание, а потом передаем управление необходимому блоку кода. Обещание может быть разрешено один раз и с тех пор оно неизменно, так что надежность нашего кода резко возрастает.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "Какие инструменты вы используете при отладке?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "При первой встрече с проблемой я, не спеша усложнять себе жизнь, обращаюсь к console.log. Если это не помогает, вызываю тяжелую артиллерию в виде браузерного отладчика.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 26,
    question: "Какие конструкции языка вы используете для обхода массивов и объектов?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "В случае с массивами, это чаще всего forEach и map. Реже возникает необходимость в for, for in, for of, reduce, filter и подобных. А чтобы обойти объект, понадобится немного изобретательности. Один из вариантов - получить ключи с помощью Object.keys, по которым впоследствии пройти с помощью forEach. Либо же можно воспользоваться Object.values, Object.entries, Object.keys.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question: "Объясните разницу между изменяемыми и неизменяемыми значениями",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Значения примитивных типов (например, строка или число) не могут быть изменены после того, как попали в память. Значения объектных типов (объекты, массивы) могут изменяться в ходе работы программы.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "Объясните разницу между синхронными и асинхронными функциями",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "JavaScript - это однопоточный язык, то-есть функции выполняются в синхронном порядке. Приложение блокируется на время выполнения каждой конкретной функции. Так происходит по той причине, что JavaScript имеет только один стек вызовов. С другой стороны, есть асинхронный способ выполнения функций, когда мы не блокируем весь интерфейс благодаря тому, что не дожидаемся выполнения функции, а подписываемся на событие с передачей обратного вызова. Ну, или мы можем иметь дело с обещанием или с прочими внешними API вроде setTimeout. В таком случае браузер помещает обработчик события в очередь задач, а когда наступает время его вызвать, он перемещает его в стек вызовов.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question: "Что такое цикл событий? В чем разница между стеком вызовов и очередью задач?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Стек вызовов - это структура данных (первым вошел, последним вышел), используемая для отслеживания порядка выполнения функций в текущем контексте (области видимости). Очередь задач - это структура данных (первым вошел, первым вышел), используемая для отслеживания выполнения асинхронных функций, готовых оказаться в стеке вызовов. Цикл событий - это механизм, на каждом тике выполняющий функции из стека вызовов и, если он оказывается пустым, перемещающий задачи из очереди задач в стек вызовов для выполнения.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question: "В чем разница между let, const и var?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "var поднимается в начало области видимости функции при компиляции; объявляет переменную, которая может быть перезаписана; объявляет переменную, которая может быть переопределена; let поднимается в начало области видимости блока при компиляции; объявляет переменную, которая может быть перезаписана; объявляет переменную, которая не может быть переопределена; const поднимается в начало области видимости блока при компиляции; объявляет переменную, которая не может быть перезаписана или переопределена",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 31,
    question: "В чем разница между ES6 class и ES5 function constructor?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Классы, добавленные в стандарте EcmaScript 6, всего лишь синтаксический сахар поверх всем известных прототипов. В работе эти подходы отличаются уровнем абстракции, который ожидаемо выше у классов - разработчику не приходится напрямую работать с прототипами.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 32,
    question: "Что такое функция высшего порядка?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Функция, принимающая функцию обратного вызова в качестве аргумента.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 33,
    question: "Что такое DOM?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "DOM - Document Object Model (объектная модель документа). Другими словами, это дерево всех узлов страницы, которые распознал браузер в процессе обработки HTML-разметки. DOM - это интерфейс, позволяющий JavaScript-коду взаимодействовать с шаблоном",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 34,
    question: "В чем разница между областью видимости функции и блочной областью видимости?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "И то, и то является полноценной областью видимости. Различие наблюдается при использовании ключевого слова var, которое ограничивается только областью видимости функции, но не блочной областью видимости.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 35,
    question: "Что произойдет в результате выражения var foo = 10 + '20' и почему?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1: "Переменная foo примет значение '1020'. В JavaScript это поведение называется приведением типов. Если хотя бы один из операндов является строкой, второй также будет преобразован в строку.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  
];

// вставить в массов ключ
questionsJSHabr35.forEach((question, i) => {
  question.option = i++;
  delete question.id;
  question.city = "";
});



// console.log(Array.isArray(questionsJSHabr35));

// console.log(questionsJSHabr35);

let questionJavaScript = questionsJSHabr.concat(...questionsJSProglib);
// console.log(questionJavaScript);

export { questionsJSHabr };
export { questionsJSProglib };
export { questionsJSHabr35 };
export { questionJavaScript };
