const questionsJSHabr = [
  /* https://habr.com/ru/articles/486820/ */

  {
    id: 1,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#1",
      linkName: "answer on habr.com",
      answer1:
        "Для начала давайте поговорим о том, что у них общего.Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS (Number, String, Boolean, Symbol, undefined, null, BigInt). Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора '!!' является false.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },

  {
    id: 2,
    question: "Для чего используется оператор ' && ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#2",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '&&' (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: console.log(false && 1 && []) // false, console.log(' ' && true && 5) // 5. При этом второй операнд не вычисляется.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Для чего используется оператор ' || ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#3",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '||' (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question:
      "Является ли использование унарного плюса (оператор ' + ') самым быстрым способом преобразования строки в число?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#4",
      linkName: "answer on habr.com",
      answer1:
        "Согласно MDN оператор " +
        " действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Что такое DOM?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#5",
      linkName: "answer on habr.com",
      answer1:
        "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.",
      image1: "",
      href2: "https://learn.javascript.ru/dom-nodes",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Основой HTML-документа являются теги.В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Что такое распространение события (Event Propogation)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#6",
      linkName: "answer on habr.com",
      answer1:
        "Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы: 1. Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков. 2. Целевая фаза — это когда событие достигает целевого элемента. 3. Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое всплытие события (Event Bubbling)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#7",
      linkName: "answer on habr.com",
      answer1:
        "Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. Поэтому если кликнуть на <p>, то мы увидим три оповещения: p → div → form.Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде. Почти все события всплывают. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают. Всегда можно узнать, на каком конкретно элементе произошло событие. Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target. Отличия от this (=event.currentTarget): 1. event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен. 2. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик. Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Что такое погружение события (Event Capturing)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#8",
      linkName: "answer on habr.com",
      answer1:
        "Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков. У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения. Если мы кликнем по элементу child, то увидим в консоли следующее: window, document, html, grandparent, parent, child. Это и есть погружение события.",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной. То есть при клике на <td> событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики. Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах. Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так: elem.addEventListener(..., {capture: true}) Существуют два варианта значений опции capture: Если аргумент false (по умолчанию), то событие будет поймано при всплытии. Если аргумент true, то событие будет перехвачено при погружении.  Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение. ",
      image2: "",
    },
  },
  {
    id: 9,
    question:
      "В чем разница между методами event.preventDefault() и event.stopPropagation()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#9",
      linkName: "answer on habr.com",
      answer1:
        "Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для этого нужно вызвать метод event.stopPropagation(). Event.preventDefault() Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п. Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события. Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.",
      image2: "",
      href3: "https://doka.guide/js/event-prevent-default/",
      linkName3: "DOKA.GUIDE",
      answer3:
        "Методы event.preventDefault() и event.stopPropagation() предназначены для решения похожих задач и часто используются вместе. Метод event.stopPropagation() останавливает распространение события (event propagation). Распространение события включает стадию захвата и стадию всплытия. Например, рассмотрим обработку события на стадии захвата — при распространении события от родительских элементов к дочерним. Обработчик, объявленный в дочернем элементе, не будет вызван после выполнения stopPropagation() в обработчике родительского элемента. При этом действие по умолчанию не отменится. Метод event.preventDefault() отменяет действие по умолчанию. Например, переход по ссылке при клике на элемент <a>. Само событие продолжает распространяться после выполнения preventDefault().",
      image3: "",
    },
  },
  {
    id: 10,
    question: "Как узнать об использовании метода event.preventDefault()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#10",
      linkName: "answer on habr.com",
      answer1:
        "Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Почему obj.someprop.x приводит к ошибке?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#11",
      linkName: "answer on habr.com",
      answer1:
        "const obj = {} console.log(obj.someprop.x) Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Что такое цель события или целевой элемент (event.target)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#12",
      linkName: "answer on habr.com",
      answer1:
        "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Что такое текущая цель события (event.currentTarget)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#13",
      linkName: "answer on habr.com",
      answer1:
        "Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "В чем разница между операторами ' == ' и ')' === ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#14",
      linkName: "answer on habr.com",
      answer1:
        ("Разница между оператором " ==
          " (абстрактное или нестрогое равенство) и оператором ") ===
        " (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question:
      "Почему результатом сравнения двух похожих объектов является false?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#15",
      linkName: "answer on habr.com",
      answer1:
        "let a = {a: 1} let b = {a: 1} let c = a console.log(a === b) // false console.log(a === c) // true хм... В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Для чего используется оператор '!!'?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#16",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '!!' (двойное отрицание) приводит значение справа от него к логическому значению. console.log(!!null) // false, console.log(!!undefined) // false, console.log(!![])  //true, console.log(!!1)  //true",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Как записать несколько выражений в одну строку?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#17",
      linkName: "answer on habr.com",
      answer1:
        "Для этого мы можем использовать оператор ',' (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Что такое поднятие (Hoisting)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#18",
      linkName: "answer on habr.com",
      answer1:
        "Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости. Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения. Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение. Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.). Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются. Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются. После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Glossary/Hoisting",
      linkName2: "mdn web docs_",
      answer2:
        "Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. Однако, hoisting может привести и к недоразумениям. Например, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что такое область видимости (Scope)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#19",
      linkName: "answer on habr.com",
      answer1:
        "Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде. Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции. Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него. Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).",
      image1: "",
      href2: "https://doka.guide/js/closures/",
      linkName2: "DOKA.GUIDE",
      answer2:
        "Не все переменные одинаково доступны — всё зависит от того, в каком месте кода их объявили. Разбираемся, почему так. Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют области видимости. Область видимости — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом. Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка. Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки. Глобальная область видимости — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости. Переменные в глобальной области видимости называются глобальными переменными и доступны всем. Самый известный пример глобальной переменной — это console. JS в браузерах так устроен, что глобальные переменные попадают в объект window. Если очень грубо, то можно сказать, что window в случае браузера — это и есть глобальная область видимости. Модульная область видимости - при использовании ES-модулей переменная, объявляемая вне функций, будет доступна, но только в том же модуле, где она создана. Чтобы предоставить доступ к определённым данным модуля, их нужно экспортировать. Разделение на модули упрощает задачу структурирования кода. Это особенно важно для больших проектов. Блочная область видимости ограничена программным блоком, обозначенным при помощи { и }. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости. Функциональная область видимости — это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции. Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Что такое замыкание (Closures)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#20",
      linkName: "answer on habr.com",
      answer1:
        "Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание. По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures",
      linkName2: "mdn web docs",
      answer2:
        "Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.",
      image2: "",
    },
  },
  {
    id: 21,
    question: "Какие значения в JS являются ложными?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#21",
      linkName: "answer on habr.com",
      answer1:
        "const falsyValues = ['', 0, null, undefined, NaN, false] Ложными являются значения, результатом преобразования которых в логическое значение является false.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "Как проверить, является ли значение ложным?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#22",
      linkName: "answer on habr.com",
      answer1:
        "Следует использовать функцию Boolean или оператор '!!' (двойное отрицание).",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "Для чего используется директива «use strict»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#23",
      linkName: "answer on habr.com",
      answer1:
        "«use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах. Вот какие ограничения накладывает строгий режим: 1. Нельзя присваивать значения или обращаться к необъявленным переменным 2. Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи 3. Нельзя удалить «неудаляемое» свойство объекта 4. Запрещено дублирование параметров 5. Нельзя создавать функции с помощью функции eval 6. Значением «this» по умолчанию является undefined",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question: "Какое значение имеет this?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#24",
      linkName: "answer on habr.com",
      answer1:
        "Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "Что такое прототип объекта?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#25",
      linkName: "answer on habr.com",
      answer1:
        "В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.  Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype.",
      image1: "",
      href2: "https://learn.javascript.ru/prototype-inheritance",
      linkName2: "современный учебник по JavaScript",
      answer2:
        "В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип». Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Операция записи не использует прототип. Прототип используется только для чтения свойств.",
      image2: "",
    },
  },
  {
    id: 26,
    question: "Что такое IIFE?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#26",
      linkName: "answer on habr.com",
      answer1:
        "IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function( ) { }( )), (function( ) { })( ) ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question: "Для чего используется метод Function.prototype.apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#27",
      linkName: "answer on habr.com",
      answer1:
        "Apply используется для привязки определенного объекта к значению this вызываемой функции. const details = { message: 'Hello World!'} function getMessage() {return this.message} getMessage.apply(details) // Hello World!  Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива. const person = { name: 'Marko Polo' function greeting(greetingMessage) {    return `${greetingMessage} ${this.name}` //greeting.apply(person, ['Hello']) // Hello Marko Polo",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "Для чего используется метод Function.prototype.call?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#28",
      linkName: "answer on habr.com",
      answer1:
        "Call используется для привязки определенного объекта к значению this вызываемой функции. Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую. greeting.call(person, 'Hello'); // Hello Marko Polo ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question: "В чем разница между методами call и apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#29",
      linkName: "answer on habr.com",
      answer1:
        "Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую. reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15 reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15 ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question: "Для чего используется метод Function.prototype.bind?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#30",
      linkName: "answer on habr.com",
      answer1:
        "Bind возвращает новую функцию, значением this которой является объект, указанный в к0честве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию. ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "REACT?",
      image2: "",
    },
  },
  {
    id: 31,
    question:
      "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#31",
      linkName: "answer on habr.com",
      answer1:
        "Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются. Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования. Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива: const words = ['Functional', 'Procedural', 'Object-Oriented'] const wordsLength = words.map(word => word.length). Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback: const data = { { name: 'Mark', isRegistered: true } { name: 'Mary', isRegistered: false } { name: 'Mae', isRegistered: true}}. Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив: const strs = ['I', ' ', 'am', ' ', 'Iron', ' ', 'Man'] const result = strs.reduce((acc, currentStr) => acc + str, '')",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "REACT?",
      image2: "",
    },
  },
  {
    id: 32,
    question: "Что такое функции высшего порядка (Higher Order Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#32",
      linkName: "answer on habr.com",
      answer1:
        "Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента. function higherOrderFunction(param, callback) { return callback(param) }",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 33,
    question:
      "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#33",
      linkName: "answer on habr.com",
      answer1:
        "Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 34,
    question: "Как бы Вы реализовали метод Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#34",
      linkName: "answer on habr.com",
      answer1:
        "Метод map создает новый массив с результатом вызова указанной функции для каждого элемента массива",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },

  {
    id: 35,
    question: "Как бы Вы реализовали метод Array.prototype.filter?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#35",
      linkName: "answer on habr.com",
      answer1:
        "Метод filter создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 36,
    question: "Как бы Вы реализовали метод Array.prototype.reduce?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#36",
      linkName: "answer on habr.com",
      answer1:
        "Метод reduce применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 37,
    question: "Что такое объект arguments?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#37",
      linkName: "answer on habr.com",
      answer1:
        "Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции. Преобразовать arguments в массив можно с помощью Array.prototype.slice: Array.prototype.slice.call(arguments). Запомните: в стрелочных функциях объект arguments не работает. function one() {     return arguments };  const two = function() {     return arguments }; const three = function three({  return arguments }); const four = () => arguments four() // arguments is not defined. Вызов функции four приводит к ошибке ReferenceError: arguments is not defined. Эту проблему можно решить с помощью оператора rest: const four = (...args) => args; Это автоматически поместит все параметры в массив.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 38,
    question: "Как создать объект, не имеющий прототипа?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#38",
      linkName: "answer on habr.com",
      answer1: "Это можно сделать с помощью Object.create",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 39,
    question:
      "Почему в представленном коде переменная b становится глобальной при вызове функции?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#39",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 40,
    question: "Что такое ECMAScript?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#40",
      linkName: "answer on habr.com",
      answer1:
        "ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.Последний вариант спецификации ECMA-262",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 41,
    question: "Что нового привнес в JS стандарт ES6 или ECMAScript2015?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#41",
      linkName: "answer on habr.com",
      answer1:
        "Стрелочные функции (Arrow Functions). Классы (Classes). Шаблонные строки (Template Strings). Расширенные объектные литералы (Enhanced Object literals). Деструктуризация (Object Destructuring). Промисы (Promises). Генераторы (Generators). Модули (Modules). Symbol. Прокси (Proxies). Множества (Sets). Параметры по умолчанию. Операторы rest и spread. Блочная область видимости (ключевые слова «let» и «const»).",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 42,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Это означает, что они доступны из любого места в коде. Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }). Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную).",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 43,
    question: "Что такое стрелочные функции (Arrow Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#43",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 44,
    question: "Что такое классы (Classes)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#44",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 45,
    question: "Что такое шаблонные литералы (Template Literals)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#45",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 46,
    question: "Что такое деструктуризация объекта (Object Destructuring)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#46",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 47,
    question: "Что такое модули (Modules)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#47",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 48,
    question: "Что такое объект Set?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#48",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 49,
    question: "Что такое функция обратного вызова (Callback Function)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#49",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 50,
    question: "Что такое промисы (Promises)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#50",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 51,
    question: "Что такое async/await?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#51",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 52,
    question: "В чем разница между spread-оператором и rest-оператором?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#52",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 53,
    question: "Что такое параметры по умолчанию (Default Parameters)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#53",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 54,
    question: "Что такое объектная обертка (Wrapper Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#54",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 55,
    question:
      "В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#55",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 56,
    question: "Что такое NaN? Как проверить, является ли значение NaN?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#56",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 57,
    question: "Как проверить, является ли значение массивом?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#57",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 58,
    question:
      "Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора ' % ')?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#58",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 59,
    question: "Как определить наличие свойства в объекте?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#59",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 60,
    question: "Что такое AJAX?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#60",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 61,
    question: "Как в JS создать объект?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#61",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 62,
    question: "В чем разница между методами Object.freeze и Object.seal?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#62",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 63,
    question: "В чем разница между оператором «in» и методом hasOwnProperty?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#63",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 64,
    question: "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#64",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 65,
    question:
      "В чем разница между обычной функцией и функциональным выражением?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#65",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 66,
    question: "Как в JS вызвать функцию?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#66",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 67,
    question: "Что такое запоминание или мемоизация (Memoization)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#67",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 68,
    question: "Как бы Вы реализовали вспомогательную функцию запоминания?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#68",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 69,
    question:
      "Почему typeof null возвращает object? Как проверить, является ли значение null?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#69",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 70,
    question: "Для чего используется ключевое слово «new»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#70",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },

  /* ----------------------------- */

  // {
  //   id: 1,
  //   question: "",
  //   answer: {
  //     href: "",
  //     linkName: "",
  //     answer1: "",
  //     image1: "",
  //     href2: "",
  //     linkName2: "",
  //     answer2: "",
  //     image2: "",
  //   },
  // },
];




const questionsJSProglib = [
  {
    id: 1,
    question: "Какие типы данных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Number – число. Тип Number в JavaScript может хранить как целые числа, так и числа с плавающей точкой. BigInt – используется для представления целых чисел произвольной длины, превышающих 2^53 – 1. BigInt создается с помощью добавления n в конец целочисленного литерала или путем вызова функции BigInt(), которая создает BigInt из строк, чисел и т.д String – строка (последовательность символов), например, 'JavaScript – главный язык интернета'.Строки записываются с использованием кавычек, можно использовать одинарные или двойные кавычки.Boolean – логический (булев) тип, который может принимать значения true (истина) или false (ложь). Object – объект. Это значение в памяти, на которое возможно сослаться с помощью идентификатора. Объект может расцениваться как набор свойств. Значения свойств могут иметь любой тип, включая другие объекты, что позволяет строить сложные, разветвленные иерархии данных. Null – специальное значение, которое представляет «ничего», «пусто», или «неизвестное значение». Undefined – это значение присваивается переменной, если она была объявлена, но не получила значения. Symbol – это уникальный и неизменяемый тип данных, который можно использовать в качестве идентификатора для свойств объекта.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "В чем состоит различие между == и ===?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript операторы == и === используются для сравнения двух значений, но они работают по-разному: == проверяет на абстрактное равенство, то есть он преобразует типы данных перед сравнением – например, если вы сравниваете строку с числом, JavaScript преобразует строку в число перед сравнением. Если строка не может быть преобразована в число, она преобразуется в NaN, что возвращает false. Если оба операнда имеют разные типы данных, но они могут быть преобразованы в один и тот же тип данных и имеют одно и то же значение, оператор == вернет true. Оператор === проверяет на строгое равенство, то есть он не выполняет преобразование типов данных. Если два значения имеют разные типы данных, оператор === вернет false, даже если они имеют одно и то же значение. Если оба операнда имеют одинаковый тип данных и одинаковое значение, оператор=== вернетtrue",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Какие способы объявления переменных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript есть четыре способа объявления переменных: 1. myVariable = 5; – неявное объявление переменной. Оно создает глобальную переменную myVariable и присваивает ей значение 5, что может привести к ошибкам в строгом режиме. 2. var myVariable = 5; – явное объявление переменной с использованием ключевого слова var. Область видимости переменной myVariable может быть функциональной или глобальной, если она объявлена вне функции. Недостаток var состоит в том, что ее область видимости не ограничивается блоком, в котором используется переменная. 3. let myVariable = 5;– явное объявление переменной с использованием ключевого слова let. Область видимости такой переменной ограничивается блоком, в котором она объявлена – на уровне функции она не видна 4.const myVariable = 5; – это явное объявление переменной с использованием ключевого слова const. Переменная myVariable объявляется в области видимости блока, как и let. Однако, в отличие отlet, переменная myVariable является неизменяемой – ее значение не может быть изменено после объявления, за одним исключением: если значение является объектом или массивом, его свойства или элементы могут быть изменены, но сама переменная все равно остается неизменяемой",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript и null, и undefined представляют отсутствие значения, но они используются в разных контекстах и имеют разные семантические значения. Undefined – присваивается переменной, когда она объявлена, но ей не присвоено конкретное значение. Null – специальное значение, которое представляет «ничего», «пусто» или «неизвестное значение». Присваивается переменной вручную, чтобы указать, что она не должна иметь значения. Например, если нужно очистить значение переменной, можно установить его в null",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Чем стрелочные функции отличаются от обычных?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Стрелочные функции позволяют использовать упрощенный синтаксис при создании небольших функций-обработчиков. У них есть некоторые ограничения по сравнению с обычными функциями: Стрелочные функции не могут использовать объект arguments. В обычных функциях этот объект содержит все переданные при вызове аргументы. У стрелочных функций другой синтаксис записи. Они записываются короче, используя стрелку => и не требуя ключевого слова function. У стрелочных функций нет собственного контекста this. Вместо этого контекст берется из внешней области видимости. Стрелочные функции нельзя использовать как конструкторы с ключевым словом new. То есть, из них нельзя создавать объекты при помощи оператора new",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Что такое замыкание?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Замыкание (closure) в JavaScript – это комбинация функции и лексического окружения, в котором эта функция была определена. Такая функция имеет доступ к переменным внешней функции, даже после того, как внешняя функция завершила выполнение",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое шаблонные строки (литералы)?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Шаблонные строки (template literals) в JavaScript – это новый способ работы со строками, введенный в ECMAScript 6 (ES6). Они обозначаются обратными кавычками ` вместо одинарных или двойных кавычек. Шаблонные строки позволяют создавать многострочные строки без необходимости использования специальных символов или конкатенации строк. Шаблонные строки также поддерживают интерполяцию строк, что позволяет вставлять выражения прямо в строку. Эти выражения заключаются в фигурные скобки ${expression} и вычисляются при создании строки",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Что такое Map и Set в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Map и Set – это два типа коллекций, которые были введены в ECMAScript 6 (ES6). Они предоставляют более гибкие и мощные способы работы с наборами данных по сравнению с обычными объектами и массивами. Map – это коллекция, которая состоит из пар ключ-значение, подобно объектам. Основное отличие Map от объектов заключается в том, что Map запоминает порядок добавления пар и позволяет использовать в качестве ключей данные любых типов. При желании в Map в качестве ключей можно использовать функции. Set – это множество, в котором каждое значение может появляться только один раз. Дубликатов в Set нет.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Как проверить наличие свойства в объекте?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript есть два основных способа проверить наличие свойства в объекте – метод hasOwnProperty и оператор in. Метод hasOwnProperty()возвращает true, если указанное свойство является прямым свойством объекта, и false в противном случае. Этот метод не проверяет свойства в цепочке прототипов объекта. Оператор in возвращает true, если указанное свойство существует в объекте, независимо от того, является ли оно собственным свойством или унаследовано.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Как получить доступ к свойствам объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "В JavaScript есть два основных способа доступа к свойствам объекта: статический (с использованием точечной нотации) и динамический (с использованием квадратных скобок).Точечная нотация позволяет напрямую получить доступ к свойству объекта, используя имя свойства. Скобочная нотация позволяет динамически получить доступ к свойству объекта с использованием квадратных скобок. Скобочная нотация использует интерполяцию и особенно полезна, если имя свойства неизвестно заранее или когда оно хранится в переменной",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Какие основные методы работы с массивами есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Oсновные методы для работы с массивами – forEach, filter, map и reduce. МетодforEach выполняет функцию для каждого элемента в массиве. Он не возвращает ничего, но позволяет выполнять действия с каждым элементом массива. Применяется, когда нужно выполнить некоторые операции над каждым элементом, но не нужно создавать новый массив. Метод filter создает новый массив, включающий только те элементы исходного массива, для которых функция обратного вызова возвращает true. Используется, когда нужно отфильтровать массив, чтобы включить только определенные элементы. Метод mapсоздает новый массив, который состоит из результатов применения функции к каждому элементу исходного массива. Применяется, когда нужно преобразовать каждый элемент массива. Метод reduce выполняет функцию для каждого элемента массива, накапливая результат в одном значении. Используется, когда нужно объединить все элементы массива в одно значение, например, вычислить сумму всех чисел в массиве",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Какие способы создания объектов есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Объекты JavaScript создаются с помощью функции-конструктора, литеральной нотации объекта, класса и метода Object.create().Функция-конструктор – это специальная функция, которую можно использовать для создания объектов с определенными свойствами и методами. Функция-конструктор используется с ключевым словом new. Литеральная нотация объекта позволяет создать объект, указав его свойства и значения внутри фигурных скобок {}. Классы позволяют создавать объекты с помощью синтаксиса, похожего на классы в других языках программирования. Метод Object.create() позволяет создать новый объект, используя существующий объект в качестве прототипа для нового объекта. Этот метод принимает два аргумента: прототип и объект свойств. Объект свойств определяет свойства нового объекта и их атрибуты configurable, enumerable, writable и value.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Что такое Promise (промис)?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода. Он имеет три состояния: 1. pending – начальное состояние, означает, что асинхронная операция еще не завершена. 2. fulfilled – операция успешно завершена. 3. rejected – операция завершена с ошибкой. Промисы создаются с помощью конструктора new Promise(). Этот конструктор принимает в качестве аргумента функцию, которая выполняет асинхронную операцию. Функция принимает два аргумента resolve и reject, которые используются для изменения состояния промиса. Если асинхронная операция завершена успешно, вызывается resolve, если произошла ошибка, вызывается reject. Промисы позволяют обрабатывать результаты асинхронных операций, используя методы .then() и .catch(). Метод.then() принимает два аргумента: функцию обратного вызова, которая будет вызвана при успешном выполнении промиса, и функцию обратного вызова, которая будет вызвана при ошибке. Метод.catch() используется для обработки ошибок, которые могут произойти при выполнении промиса. Промисы можно связывать в цепочки, что позволяет выполнять несколько асинхронных операций последовательно. Для этого результат каждого промиса передается в следующий промис в цепочке. Это делается с помощью метода .then(). Промисы также могут быть использованы для создания асинхронных операций, которые зависят от других операци",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "Что такое async/await и как они используются?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Async/await – это синтаксис JavaScript, который облегчает работу с промисами. Ключевое слово async перед функцией означает, что функция всегда возвращает промис. Ключевое слово awaitиспользуется внутри асинхронных функций и заставляет JavaScript ожидать, пока промис не будет выполнен, прежде чем продолжить выполнение кода. Надо отметить, что await нельзя использовать вне асинхронной функции. Например, этот код приведет к ошибке. Чтобы решить эту проблему, можно обернуть вызов в другую асинхронную функцию",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "Как проверить, является ли объект массивом?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Для такой проверки можно использовать встроенный методArray.isArray(). Этот метод принимает объект в качестве аргумента и возвращает true, если объект является массивом, и falseв противном случае",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Что делает оператор расширения?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Оператор расширения ... разворачивает итерируемые элементы в отдельные элементы, что удобно для передачи аргументов, объединения массивов/объектов и добавления новых свойств в объекты. Используется: 1. В функциях, где ожидаемое количество аргументов для вызова равно нулю или более 2. В литералах массива 3. В литералах объекта, где количество пар ключ-значение должно быть равно нулю или более 4. Для преобразования строки в массив символов 5. Для преобразования числа в массив цифр и наоборот 6. Для копирования объектов",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Как выполняется клонирование объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Если объект не содержит вложенных объектов, как в приведенном ниже примере, для клонирования можно использовать оператор расширения...или метод Object.assign(). Если объект содержит вложенные объекты, нужно выполнить глубокое копирование. Относительно медленный вариант – с использованием JSON. Другой вариант – с использованием метода cloneDeep из библиотеки lodash.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Как изменить контекст функции?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Изменить контекст функции можно с помощью методов bind(),call() и apply(). Метод bind() возвращает новую функцию с привязанным контекстом. Метод call() принимает последовательность аргументов, а apply() принимает массив аргументов в качестве второго параметра",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что такое тернарный оператор и как он работает?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Тернарный оператор – это сокращенная форма записи if-else. Он называется тернарным, потому что является единственным оператором в JavaScript, который принимает три аргумента. Синтаксис тернарного оператора: условие ? выражение_если_истинно : выражение_если_ложно. Условие – любое условие, которое возвращает true или false. Выражение для истинного условия – что нужно вернуть, если условие истинно. Выражение для ложного условия – что нужно вернуть, если условие ложно.",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Что такое деструктуризация?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "Деструктуризация в JavaScript позволяет извлечь данные из массива или свойства объекта и присвоить их отдельным переменным. Деструктуризация удобна тем, что позволяет не писать лишний код для доступа к данным внутри объектов/массивов по индексам или ключам.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

export { questionsJSHabr };
export { questionsJSProglib };
