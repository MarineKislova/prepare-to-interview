/* Общий список вопросов по Javascript */
const questionsJS = [
  {
    id: 1,
    question: "Какие типы данных (примитивные типы данных) есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<ul> <li><span>Number</span> – число. Тип Number в JavaScript может хранить как целые числа, так и числа с плавающей точкой.</li> <li><span>BigInt</span> – используется для представления целых чисел произвольной длины, превышающих 2^53 – 1. BigInt создается с помощью добавления n в конец целочисленного литерала или путем вызова функции BigInt(), которая создает BigInt из строк, чисел и т.д.</li> <li><span>String</span> – строка (последовательность символов), например, 'JavaScript – главный язык интернета'.Строки записываются с использованием кавычек, можно использовать одинарные или двойные кавычки.</li> <li><span>Boolean</span> – логический (булев) тип, который может принимать значения true (истина) или false (ложь).</li> <li><span>Object</span> – объект. Это значение в памяти, на которое возможно сослаться с помощью идентификатора. Объект может расцениваться как набор свойств. Значения свойств могут иметь любой тип, включая другие объекты, что позволяет строить сложные, разветвленные иерархии данных.</li> <li><span>Null</span> – специальное значение, которое представляет «ничего», «пусто», или «неизвестное значение».</li> <li><span>Undefined</span> – это значение присваивается переменной, если она была объявлена, но не получила значения.</li> <li><span>Symbol</span> – это уникальный и неизменяемый тип данных, который можно использовать в качестве идентификатора для свойств объекта.</li> </ul>",
      image1: "",
      href2: "https://habr.com/ru/articles/784548/",
      linkName2: "habr.com",
      answer2:
        "<p>Часто кандидаты ошибаются, когда отвечают на этот вопрос, почему так происходит не понятно</p> <p>Всего в JS 8 типов данных:</p> <p><span>Число (number)</span>, <span>Строка (string)</span>, <span>Булевый (логический) тип (boolean)</span>, <span>BigInt</span>, <span>Symbol</span>, <span>undefiend</span>, <span>Object</span>, <span>Null</span></p>",
      image2: "",
      href3:
        "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName3: "proglib.io",
      answer3:
        "<p>Такой вопрос обычно оценивает ваши теоретические знания JavaScript. При ответе на этот вопрос рассмотрите возможность краткого перечисления всех примитивных типов данных, доступных в JavaScript.</p> <p><span>Ответ:</span>Фундаментальный тип данных, который не может быть создан от других типов данных. Он ограничен представлением одного значения. Все примитивы неизменяемы (immutable), не являются объектом и не имеют методов. По определению, все примитивы – встроенные типы данных, и компилятор должен знать их. Но не все встроенные типы данных – примитивы. В JavaScript доступно семь примитивных типов данных: <span>undefined, null, boolean, string, number, bigint, symbol</span>. Все остальное в JavaScript является объектом.</p>",
      image3: "",
    },
  },
  {
    id: 2,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#1",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для начала давайте поговорим о том, что у них общего.</p> <p>Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS (Number, String, Boolean, Symbol, undefined, null, BigInt).</p> <p>Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора '!!' является false.</p> <p><span>undefined («неопределенный»)</span> представляет собой значение по умолчанию:</p> <ul> <li>переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;</li> <li>функции, которая ничего не возвращает явно, например, console.log(1);</li> <li>несуществующего свойства объекта.</li> </ul> <p></p> В указанных случаях движок JS присваивает значение <span>undefined.</span> <p><img class='question__img' src='img/habr70/1.1habr70.png' alt=''></p> <p><span>null</span> — это «значение отсутствия значения». <span>null</span> — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:</p> <p><img class='question__img' src='img/habr70/1.2habr70.png' alt=''></p> <p>При сравнении <span>null</span> и <span>undefined</span> мы получаем <span>true</span>, когда используем оператор '==', и <span>false</span> при использовании оператора '==='. О том, почему так происходит, см. ниже.</p> <p><img class='question__img' src='img/habr70/1.3habr70.png' alt=''></p>",
      image1: "",
      href2:
        "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName2: "proglib.io",
      answer2:
        "<p>В JavaScript и <span>null</span>, и <span>undefined</span> представляют отсутствие значения, но они используются в разных контекстах и имеют разные семантические значения.</p> <p><span>Undefined</span> – присваивается переменной, когда она объявлена, но ей не присвоено конкретное значение.</p> <p><span>Null</span> – специальное значение, которое представляет «ничего», «пусто» или «неизвестное значение». Присваивается переменной вручную, чтобы указать, что она не должна иметь значения. Например, если нужно очистить значение переменной, можно установить его в null</p>",
      image2: "",
      href3: "https://habr.com/ru/articles/784548/",
      linkName3: "habr.com",
      answer3:
        "<p>Null и undefined - это два различных значения в JavaScript, которые указывают на отсутствие значения.</p> <p>Различия:</p> <ul> <li>null - это явное значение, которое указывает на отсутствие или намеренное присвоение пустого значения. undefined - это значение, которое указывает на отсутствие присвоенного значения</li> <li>null - это объектный тип данных, который представляет отсутствие объекта. undefined - это примитивный тип данных.</li> <li>null может быть присвоен явно, чтобы указать на отсутствие значения. undefined - это значение, которое присваивается переменной по умолчанию, когда она объявлена, но не инициализирована.</li> </ul> <p>Сходства:</p> <ul> <li>Осутствие значения: Оба значения, null и undefined, указывают на отсутствие значения.</li> <li>Истинность: Оба значения рассматриваются как ложные (falsy) в логическом контексте. Это означает, что они преобразуются в false, когда используются в условных выражениях.</li> <li>Присваивание: Оба значения могут быть присвоены переменным или свойствам объекта.</li> <li>Тип данных: Оба значения являются уникальными значениями и не имеют своих собственных типов данных.</li> </ul> <p>В целом, null используется, когда явно указывается отсутствие значения, в то время как undefined указывает на отсутствие присвоенного значения.</p>",
      image3: "",
    },
  },
  {
    id: 3,
    question: "В чем разница между null, undefined и undeclared?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>null - это в прямом смысле 'ничего'. Можно использовать это значение в качестве плейсхолдера.</p> <p>undefined - это значение для случая 'объявлено, но не инициализировано'.</p> <p>undeclared - это ошибка, возникающая в случае обращении к необъявленной переменной.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 4,
    question: "В чем разница между undefined и is not defined?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>undefined - это значение, присваемое объявленной, но не проинициализированной переменной. Мы получаем undefined, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку is not defined</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 5,
    question: "Какие значения в JS являются ложными?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#21",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>const falsyValues = ['', 0, null, undefined, NaN, false]</span><br>Ложными являются значения, результатом преобразования которых в логическое значение является false.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 6,
    question: "Как проверить, является ли значение ложным?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#22",
      linkName: "answer on habr.com",
      answer1:
        "<p>Следует использовать <span>функцию Boolean</span> или <span>оператор '!!'</span> (двойное отрицание).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 7,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "<p>Переменные, объявленные с помощью ключевого слова <span>«var»</span>, являются глобальными. Это означает, что они доступны из любого места в коде.</p> <p>Переменные, объявленные с помощью ключевых слов <span>«let»</span> и <span>«const»</span> имеют блочную область видимости. Это означает, что они доступны только внутри блока <span>({ })</span>.</p> <p>Разница между <span>«let»</span> и <span>«const»</span> состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью <span>const</span>, но не само свойство (переменную).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 8,
    question: "Какие способы объявления переменных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript есть четыре способа объявления переменных:</p> <p>1. <span>myVariable = 5;</span> – неявное объявление переменной. Оно создает глобальную переменную myVariable и присваивает ей значение 5, что может привести к ошибкам в строгом режиме ('use strict').</p> <p>2. <span>var myVariable = 5;</span> – явное объявление переменной с использованием ключевого слова var. Область видимости переменной myVariable может быть функциональной или глобальной, если она объявлена вне функции. Недостаток var состоит в том, что ее область видимости не ограничивается блоком, в котором используется переменная.</p> <p>3. <span>let myVariable = 5;</span>– явное объявление переменной с использованием ключевого слова let. Область видимости такой переменной ограничивается блоком, в котором она объявлена – на уровне функции она не видна</p> <p>4. <span>const myVariable = 5;</span> – это явное объявление переменной с использованием ключевого слова const. Переменная myVariable объявляется в области видимости блока, как и let. Однако, в отличие от let, переменная myVariable является неизменяемой – ее значение не может быть изменено после объявления, за одним исключением: если значение является объектом или массивом, его свойства или элементы могут быть изменены, но сама переменная все равно остается неизменяемой</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 9,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "<p>Переменные, объявленные с помощью ключевого слова <span>«var»</span>, являются глобальными. Это означает, что они доступны из любого места в коде.</p> <p>Переменные, объявленные с помощью ключевых слов <span>«let»</span> и <span>«const»</span> имеют блочную область видимости. Это означает, что они доступны только внутри блока <span>({ })</span>.</p> <p>Разница между <span>«let»</span> и <span>«const»</span> состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью <span>const</span>, но не само свойство (переменную).</p>",
      image1: "",
      href2:
        "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName2: "tproger.ru",
      answer2:
        "<p>let, var и const — это ключевые слова, используемые в JavaScript для объявления переменных.</p> <p>var долгое время был основным способом объявления переменных в JavaScript до появления let и const. var имеет область видимости функции и может быть изменен в любом месте в этой функции.</p> <p>let и const были добавлены в стандарт ECMAScript 6 (ES6) и имеют блочную область видимости. let может быть изменен, но const не может</p> <p>Используйте let, если вы собираетесь изменять значение переменной, и const, если не собираетесь. Используйте var, если вам нужно поддерживать совместимость со старыми браузерами или если вы хотите использовать его особенности, такие как функциональная область видимости.</p>",
      image2: "",
      href3: "https://habr.com/ru/articles/784548/",
      linkName3: "habr.com",
      answer3:
        "<p>Начнем с var:</p> <ul> <li>Переменные, объявленные с помощью var, имеют функциональную область видимости или область видимости внутри целого файла.</li> <li>Переменные var могут быть переопределены и переобъявлены в той же области видимости.</li> <li>Переменные var поднимаются (hoisted) в начало своей области видимости, что означает, что их можно использовать до их фактического объявления.</li> </ul> <p>let:</p> <ul> <li>Переменные, объявленные с помощью let, имеют блочную область видимости, ограниченную фигурными скобками {}.</li> <li>Переменные let не могут быть переобъявлены в той же области видимости, но могут быть переопределены.</li> <li>Переменные let не поднимаются (не hoisted) и не могут быть использованы до их объявления.</li> </ul> <p>const:</p> <ul> <li>Переменные, объявленные с помощью const, также имеют блочную область видимости.</li> <li>Переменные const должны быть инициализированы при объявлении и их значение не может быть изменено после этого.</li> <li>Переменные const не могут быть переобъявлены или переопределены.</li> <li>const также создает неизменяемую ссылку на объект, поэтому значения внутри объекта могут быть изменены, но сама ссылка остается неизменной.</li> </ul>",
      image3: "",
      href4: "https://habr.com/ru/articles/578370/",
      linkName4: "35 вопросов с собеседования JavaScript-разработчика",
      answer4:
        "<p>var </p> <ul> <li>поднимается в начало области видимости функции при компиляции;</li> <li>объявляет переменную, которая может быть перезаписана;</li> <li>объявляет переменную, которая может быть переопределена;</li> </ul> <p>let</p> <ul> <li>поднимается в начало области видимости блока при компиляции;</li> <li>объявляет переменную, которая может быть перезаписана;</li> <li>объявляет переменную, которая не может быть переопределена;</li> </ul> <p>const</p> <ul> <li>поднимается в начало области видимости блока при компиляции;</li> <li>объявляет переменную, которая не может быть перезаписана или переопределена</li> </ul>",
      image4: "",
    },
  },
  {
    id: 10,
    question: "Что такое область видимости (Scope)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#19",
      linkName: "answer on habr.com",
      answer1:  "<p><span>Область видимости</span> — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).</p> <p><span>Глобальная область видимости</span> — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.</p> <p><img class='question__img' src='img/habr70/19.1habr70.png' alt=''></p> <p><span>Функциональная область видимости</span> (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.</p> <p><img class='question__img' src='img/habr70/19.2habr70.png' alt=''></p> <p><span>Блочная область видимости</span> — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.</p> <p><img class='question__img' src='img/habr70/19.3habr70.png' alt=''></p> <p><span>Область видимости</span> — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).</p> <p><img class='question__img' src='img/habr70/19.4habr70.png' alt=''></p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png' alt=''></p>",
      image1: "",
      href2: "https://doka.guide/js/closures/",
      linkName2: "DOKA.GUIDE",
      answer2: "<p>Не все переменные одинаково доступны — всё зависит от того, в каком месте кода их объявили.</p> <p>Разбираемся, почему так. Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.</p> <p>Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют области видимости.</p> <p><span>Область видимости</span> — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.</p> <p> Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом.</p> <p>Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка.</p> <p> Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки.</p> <p><span>Глобальная область видимости</span> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости. Переменные в глобальной области видимости называются глобальными переменными и доступны всем.</p> <p>Самый известный пример глобальной переменной — это <span>console</span>. JS в браузерах так устроен, что глобальные переменные попадают в объект <span></span>. Если очень грубо, то можно сказать, что window в случае браузера — это и есть глобальная область видимости.</p> <p><span>Модульная область видимости</span> - при использовании ES-модулей переменная, объявляемая вне функций, будет доступна, но только в том же модуле, где она создана. Чтобы предоставить доступ к определённым данным модуля, их нужно экспортировать. Разделение на модули упрощает задачу структурирования кода. Это особенно важно для больших проектов.</p> <p><span>Блочная область видимости</span> ограничена программным блоком, обозначенным при помощи { и }. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости.</p> <p><span>Функциональная область видимости</span>— это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции. Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.</p>",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 11,
    question: "Что такое поднятие (Hoisting)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#18",
      linkName: "answer on habr.com",
      answer1: "<p><span>Поднятие</span> — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.</p> <p>Для того, чтобы понять, что такое <span>Hoisting</span>, необходимо разобраться с тем, что представляет собой контекст выполнения.</p> <p><span>Контекст выполнения</span> — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.</p> <p><span>Компиляция.</span>В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).</p> <p><span>Выполнение.</span> В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.</p> <p><span>Запомните:</span> поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.</p> <p>Предположим, что у нас есть такой код:</p> <p><img class='question__img' src='img/habr70/3.1habr70.png' alt=''></p> <p>Получаем undefined, 1 и 'Hello Mark!'.</p> <p>Вот как выглядит фаза компиляции:</p> <p><img class='question__img' src='img/habr70/3.2habr70.png' alt=''></p> <p>После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.</p> <p>Дополнительно о Hoisting можно почитать<a class='question__link' href='https://developer.mozilla.org/ru/docs/Glossary/Hoisting' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Glossary/Hoisting",
      linkName2: "mdn web docs_",
      answer2: "Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. Однако, hoisting может привести и к недоразумениям. Например, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.",
      image2: "",
      href3: "https://habr.com/ru/articles/578370/",
      linkName3: "35 вопросов с собеседования JavaScript-разработчика",
      answer3: "<p>Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.</p> <p>Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.</p> <p>По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression.</p>",
      image3: "",
    },
  },
  {
    id: 12,
    question: "Для чего используется оператор ' && ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#2",
      linkName: "answer on habr.com",
      answer1: "Оператор '&&' (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: console.log(false && 1 && []) // false, console.log(' ' && true && 5) // 5. При этом второй операнд не вычисляется.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 13,
    question: "Для чего используется оператор ' || ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#3",
      linkName: "answer on habr.com",
      answer1: "Оператор '||' (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 14,
    question: "Для чего используется оператор '!!'?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#16",
      linkName: "answer on habr.com",
      answer1: "<p>Оператор '!!' (двойное отрицание) приводит значение справа от него к логическому значению.</p> <p><span>console.log(!!null) // false,<br>console.log(!!undefined) // false,<br>console.log(!![])  //true,<br>console.log(!!1)  //true</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 15,
    question: "В чем разница между операторами ' == ' и ')' === ' ?",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
  {
    id: 1,
    question: "",
    answer: {
      href: "",
      linkName: "",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },
];

export { questionsJS };
