

/* 70 вопросов по JavaScript для подготовки к собеседованию */
/* https://habr.com/ru/articles/486820/ */
const questionsJSHabr = [
  {
    id: 1,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#1",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для начала давайте поговорим о том, что у них общего.</p> <p>Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS (Number, String, Boolean, Symbol, undefined, null, BigInt).</p> <p>Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора '!!' является false.</p> <p><span>undefined («неопределенный»)</span> представляет собой значение по умолчанию:</p> <ul> <li>переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;</li> <li>функции, которая ничего не возвращает явно, например, console.log(1);</li> <li>несуществующего свойства объекта.</li> </ul> <p></p> В указанных случаях движок JS присваивает значение <span>undefined.</span> <p><img class='question__img' src='img/habr70/1.1habr70.png' alt=''></p> <p><span>null</span> — это «значение отсутствия значения». <span>null</span> — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:</p> <p><img class='question__img' src='img/habr70/1.2habr70.png' alt=''></p> <p>При сравнении <span>null</span> и <span>undefined</span> мы получаем <span>true</span>, когда используем оператор '==', и <span>false</span> при использовании оператора '==='. О том, почему так происходит, см. ниже.</p> <p><img class='question__img' src='img/habr70/1.3habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
      href3: "",
      linkName3: "",
      answer3: "",
      image3: "",
    },
  },

  {
    id: 2,
    question: "Для чего используется оператор ' && ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#2",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '&&' (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат: console.log(false && 1 && []) // false, console.log(' ' && true && 5) // 5. При этом второй операнд не вычисляется.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Для чего используется оператор ' || ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#3",
      linkName: "answer on habr.com",
      answer1:
        "Оператор '||' (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question:
      "Является ли использование унарного плюса (оператор ' + ') самым быстрым способом преобразования строки в число?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#4",
      linkName: "answer on habr.com",
      answer1:
        "Согласно MDN оператор " +
        " действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Что такое DOM?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#5",
      linkName: "answer on habr.com",
      answer1:
        "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.",
      image1: "",
      href2: "https://learn.javascript.ru/dom-nodes",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Основой HTML-документа являются теги.В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Что такое распространение события (Event Propogation)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#6",
      linkName: "answer on habr.com",
      answer1:
        "<p>Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:</p> <ol> <li>Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.</li> <li>Целевая фаза — это когда событие достигает целевого элемента.</li> <li>Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.</li> </ol> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png' alt=''></p> <p>Подробнее о распространении событий можно почитать <a class='question__link' href='https://learn.javascript.ru/bubbling-and-capturing' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://www.w3.org/TR/uievents/#event-flow' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое всплытие события (Event Bubbling)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#7",
      linkName: "answer on habr.com",
      answer1:
        "<p>Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.</p> <p>Допустим, у нас есть такая разметка:</p> <p><img class='question__img' src='img/habr70/2.1habr70.png' alt=''></p> <p>И такой JS:</p> <p><img class='question__img' src='img/habr70/2.2habr70.png' alt=''></p> <p>У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.</p>",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "Современный учебник JavaScript",
      answer2:
        "Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. Поэтому если кликнуть на <p>, то мы увидим три оповещения: p → div → form.Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде. Почти все события всплывают. Ключевое слово в этой фразе – «почти». Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают. Всегда можно узнать, на каком конкретно элементе произошло событие. Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target. Отличия от this (=event.currentTarget): 1. event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен. 2. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик. Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Что такое погружение события (Event Capturing)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#8",
      linkName: "answer on habr.com",
      answer1:
        "<p>Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков</p> <p>Допустим, у нас есть такая разметка:</p> <p><img class='question__img' src='img/habr70/2.1habr70.png' alt=''></p> <p>И такой JS:</p> <p><img class='question__img' src='img/habr70/2.2habr70.png' alt=''></p> <p>У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.</p>",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной. То есть при клике на <td> событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики. Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах. Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так: elem.addEventListener(..., {capture: true}) Существуют два варианта значений опции capture: Если аргумент false (по умолчанию), то событие будет поймано при всплытии. Если аргумент true, то событие будет перехвачено при погружении.  Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение. ",
      image2: "",
    },
  },
  {
    id: 9,
    question:
      "В чем разница между методами event.preventDefault() и event.stopPropagation()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#9",
      linkName: "answer on habr.com",
      answer1:
        "<p>Метод <span>event.preventDefault()</span> отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).</p>",
      image1: "",
      href2: "https://learn.javascript.ru/bubbling-and-capturing",
      linkName2: "современный учебник JavaScript",
      answer2:
        "Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для этого нужно вызвать метод event.stopPropagation(). Event.preventDefault() Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п. Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события. Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.",
      image2: "",
      href3: "https://doka.guide/js/event-prevent-default/",
      linkName3: "DOKA.GUIDE",
      answer3:
        "Методы event.preventDefault() и event.stopPropagation() предназначены для решения похожих задач и часто используются вместе. Метод event.stopPropagation() останавливает распространение события (event propagation). Распространение события включает стадию захвата и стадию всплытия. Например, рассмотрим обработку события на стадии захвата — при распространении события от родительских элементов к дочерним. Обработчик, объявленный в дочернем элементе, не будет вызван после выполнения stopPropagation() в обработчике родительского элемента. При этом действие по умолчанию не отменится. Метод event.preventDefault() отменяет действие по умолчанию. Например, переход по ссылке при клике на элемент <a>. Само событие продолжает распространяться после выполнения preventDefault().",
      image3: "",
    },
  },
  {
    id: 10,
    question: "Как узнать об использовании метода event.preventDefault()?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#10",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода <span>event.preventDefault</span>.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Почему obj.someprop.x приводит к ошибке?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#11",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>const obj = {} console.log(obj.someprop.x)</span> Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Что такое цель события или целевой элемент (event.target)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#12",
      linkName: "answer on habr.com",
      answer1:
        "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Что такое текущая цель события (event.currentTarget)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#13",
      linkName: "answer on habr.com",
      answer1:
        "Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "В чем разница между операторами ' == ' и ')' === ' ?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#14",
      linkName: "answer on habr.com",
      answer1:
        "<p>Разница между оператором '==' (абстрактное или нестрогое равенство) и оператором '===' (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.</p> <p>Преобразование представляет собой процесс приведения значения к другому типу или, точнее, процесс приведения сравниваемых значений к одному типу. При сравнении оператор '==' производит так называемое неявное сравнение. Оператор '==' выполняет некоторые операции перед сравнением двух значений.</p> <p>Допустим, мы сравниваем x и y.</p> <p>Алгоритм следующий:</p> <ol> <li>Если x и y имеют одинаковый тип, сравнение выполняется с помощью оператора '==='.</li> <li>Если x = null и y = undefined возвращается true.</li> <li>Если x = undefined и y = null возвращается true.</li> <li>Если x = число, а y = строка, возвращается x == toNumber(y) (значение y преобразуется в число).</li> <li>Если x = строка, а y = число, возвращается toNumber(x) == y (значение x преобразуется в число).</li> <li>Если x = логическое значение, возвращается toNumber(x) == y.</li> <li>Если y = логическое значение, возвращается x == toNumber(y).</li> <li>Если x = строка, символ или число, а y = объект, возвращается x == toPrimitive(y) (значение y преобразуется в примитив).</li> <li>Если x = объект, а y = строка, символ или число, возвращается toPrimitive(x) == y.</li> <li>Возвращается false.</li></ol> <p>Запомните: для приведения объекта к «примитиву» метод toPrimitive сначала использует метод valueOf, затем метод toString.</p> <p>Примеры:</p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png' alt=''></p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png' alt=''></p> <p>Если же мы используем оператор '===' все примеры, кроме первого, вернут false, поскольку значения в этих примерах имеют разные типы.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question:
      "Почему результатом сравнения двух похожих объектов является false?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#15",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>let a = {a: 1} <br> let b = {a: 1} <br> let c = a <br> console.log(a === b) // <br> false console.log(a === c) // true</span></p> <p>В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Для чего используется оператор '!!'?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#16",
      linkName: "answer on habr.com",
      answer1:
        "<p>Оператор '!!' (двойное отрицание) приводит значение справа от него к логическому значению.</p> <p><span>console.log(!!null) // false,<br>console.log(!!undefined) // false,<br>console.log(!![])  //true,<br>console.log(!!1)  //true</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Как записать несколько выражений в одну строку?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#17",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для этого мы можем использовать оператор ',' (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.</p> <p><span>let x = 5 <br> x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10) <br> function addFive(num) { <br> return num + 5 <br> }</span></p> <p>Если мы выведем значение x в консоль, то получим 27. Сначала мы увеличиваем значение x на единицу (x = 6). Затем вызываем функцию addFive() с параметром 6, к которому прибавляем 5 (x = 11). После этого мы умножаем значение x на 2 (x = 22). Затем вычитаем 5 (x = 17). И, наконец, прибавляем 10 (x = 27).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Что такое поднятие (Hoisting)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#18",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Поднятие</span> — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.</p> <p>Для того, чтобы понять, что такое <span>Hoisting</span>, необходимо разобраться с тем, что представляет собой контекст выполнения.</p> <p><span>Контекст выполнения</span> — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.</p> <p><span>Компиляция.</span>В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).</p> <p><span>Выполнение.</span> В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.</p> <p><span>Запомните:</span> поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.</p> <p>Предположим, что у нас есть такой код:</p> <p><img class='question__img' src='img/habr70/3.1habr70.png' alt=''></p> <p>Получаем undefined, 1 и 'Hello Mark!'.</p> <p>Вот как выглядит фаза компиляции:</p> <p><img class='question__img' src='img/habr70/3.2habr70.png' alt=''></p> <p>После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.</p> <p>Дополнительно о Hoisting можно почитать<a class='question__link' href='https://developer.mozilla.org/ru/docs/Glossary/Hoisting' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Glossary/Hoisting",
      linkName2: "mdn web docs_",
      answer2:
        "Поднятие (hoisting) — термин, который вы не встретите в документации JavaScript. Поднятие задумывалось как общий способ мышления о том, как контекст исполнения (в частности, фазы создания и исполнения) работает в JavaScript. Однако, hoisting может привести и к недоразумениям. Например, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что такое область видимости (Scope)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#19",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Область видимости</span> — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).</p> <p><span>Глобальная область видимости</span> — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.</p> <p><img class='question__img' src='img/habr70/19.1habr70.png' alt=''></p> <p><span>Функциональная область видимости</span> (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.</p> <p><img class='question__img' src='img/habr70/19.2habr70.png' alt=''></p> <p><span>Блочная область видимости</span> — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.</p> <p><img class='question__img' src='img/habr70/19.3habr70.png' alt=''></p> <p><span>Область видимости</span> — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).</p> <p><img class='question__img' src='img/habr70/19.4habr70.png' alt=''></p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png' alt=''></p>",
      image1: "",
      href2: "https://doka.guide/js/closures/",
      linkName2: "DOKA.GUIDE",
      answer2:
        "<p>Не все переменные одинаково доступны — всё зависит от того, в каком месте кода их объявили.</p> <p>Разбираемся, почему так. Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.</p> <p>Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют области видимости.</p> <p><span>Область видимости</span> — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.</p> <p> Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом.</p> <p>Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка.</p> <p> Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки.</p> <p><span>Глобальная область видимости</span> — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости. Переменные в глобальной области видимости называются глобальными переменными и доступны всем.</p> <p>Самый известный пример глобальной переменной — это <span>console</span>. JS в браузерах так устроен, что глобальные переменные попадают в объект <span></span>. Если очень грубо, то можно сказать, что window в случае браузера — это и есть глобальная область видимости.</p> <p><span>Модульная область видимости</span> - при использовании ES-модулей переменная, объявляемая вне функций, будет доступна, но только в том же модуле, где она создана. Чтобы предоставить доступ к определённым данным модуля, их нужно экспортировать. Разделение на модули упрощает задачу структурирования кода. Это особенно важно для больших проектов.</p> <p><span>Блочная область видимости</span> ограничена программным блоком, обозначенным при помощи { и }. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости.</p> <p><span>Функциональная область видимости</span>— это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции. Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.</p>",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Что такое замыкание (Closures)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#20",
      linkName: "answer on habr.com",
      answer1:
        "Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание. По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.",
      image1: "",
      href2: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures",
      linkName2: "mdn web docs",
      answer2:
        "<p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.</p> <p><span>Лексическая область видимости</span></p> <p>Рассмотрим следующий пример:</p> <p><img class='question__img' src='img/habr70/20.1habr70.png' alt=''></p> <p><span>init()</span> создаёт локальную переменную name и определяет функцию <span>displayName()</span>. <span>displayName()</span> — это внутренняя функция — она определена внутри <span>init()</span> и доступна только внутри тела функции <span>init()</span>. Обратите внимание, что функция <span>displayName()</span> не имеет никаких собственных локальных переменных. Однако, поскольку внутренние функции имеют доступ к переменным внешних функций, <span>displayName()</span> может иметь доступ к переменной name, объявленной в родительской функции <span>init()</span>.</p> <p>Выполните этот код и обратите внимание, что команда alert() внутри displayName() благополучно выводит на экран содержимое переменной name объявленной в родительской функции. Это пример так называемой лексической области видимости (lexical scoping): в JavaScript область действия переменной определяется по её расположению в коде (это очевидно лексически), и вложенные функции имеют доступ к переменным, объявленным вовне. Этот механизм и называется Lexical scoping (область действия, ограниченная лексически).</p> <p><span>Замыкание</span></p> <p>Рассмотрим следующий пример:</p> <p><img class='question__img' src='img/habr70/20.2habr70.png' alt=''></p> <p>На первый взгляд, кажется неочевидным, что этот код правильный, но он работает. В некоторых языках программирования локальные переменные-функции существуют только во время выполнения этой функции. После завершения выполнения <span>makeFunc()</span> можно ожидать, что переменная name больше не будет доступна. Однако, поскольку код продолжает нормально работать, очевидно, что это не так в случае JavaScript.</p> <p>Причина в том, что функции в <span>JavaScript</span> формируют так называемые <span>замыкания</span>. <span>Замыкание</span> — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. В рассмотренном примере <span>myFunc</span> — это ссылка на экземпляр функции <span>displayName</span>, созданной в результате выполнения <span>makeFunc</span>. Экземпляр функции <span>displayName</span> в свою очередь сохраняет ссылку на своё лексическое окружение, в котором есть переменная <span>name</span>. По этой причине, когда происходит вызов функции <span>myFunc</span>, переменная <span>name</span> остаётся доступной для использования и сохранённый в ней текст 'Mozilla' передаётся в alert.</p>",
      image2: "",
    },
  },
  {
    id: 21,
    question: "Какие значения в JS являются ложными?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#21",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>const falsyValues = ['', 0, null, undefined, NaN, false]</span><br>Ложными являются значения, результатом преобразования которых в логическое значение является false.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "Как проверить, является ли значение ложным?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#22",
      linkName: "answer on habr.com",
      answer1:
        "<p>Следует использовать <span>функцию Boolean</span> или <span>оператор '!!'</span> (двойное отрицание).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "Для чего используется директива «use strict»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#23",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>«use strict»</span> — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.</p> <p>Вот какие ограничения накладывает строгий режим:</p> <p>1. Нельзя присваивать значения или обращаться к необъявленным переменным </p> <p>2. Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи</p> <p>3. Нельзя удалить «неудаляемое» свойство объекта</p>  <p>4. Запрещено дублирование параметров</p>  <p>5. Нельзя создавать функции с помощью функции eval</p> <p>6. Значением «this» по умолчанию является undefined</p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question: "Какое значение имеет this?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#24",
      linkName: "answer on habr.com",
      answer1:
        "<p>Обычно <span>this</span> ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение <span>this</span> меняется в зависимости от контекста выполнения, от того места, где мы используем <span>this</span></p> <p><img class='question__img' src='img/habr70/24habr70.png' alt=''></p> <p>В данном случае метод getName возвращает this.name, а this ссылается на carDetails, объект, в котором выполняется getName, который является ее «владельцем».</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "Что такое прототип объекта?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#25",
      linkName: "answer on habr.com",
      answer1:
        "<p>В двух словах, <span>прототип</span> — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. </p> <p><span>const o = {}<br>console.log(o.toString()) // [object Object]</span></p> <p>Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится <span>Object.prototype</span>.</p> <p><span></span></p> <p>Подробнее о прототипах и наследовании можно почитать <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://learn.javascript.ru/prototype-inheritance' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "https://learn.javascript.ru/prototype-inheritance",
      linkName2: "современный учебник по JavaScript",
      answer2:
        "В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип». Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Операция записи не использует прототип. Прототип используется только для чтения свойств.",
      image2: "",
    },
  },
  {
    id: 26,
    question: "Что такое IIFE?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#26",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>IIFE</span> или <span>Immediately Invoked Function Expression</span> — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания <span>IIFE</span> необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так:<br><span>(function( ) { }( )), <br>(function( ) { })( )</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question: "Для чего используется метод Function.prototype.apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#27",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Apply</span> используется для привязки определенного объекта к значению this вызываемой функции.</p> <p><img class='question__img' src='img/habr70/27.1habr70.png' alt=''></p> <p>Этот метод похож на <span>Function.prototype.call</span>. Единственное отличие состоит в том, что в <span>apply</span> аргументы передаются в виде массива.</p> <p><img class='question__img' src='img/habr70/27.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "Для чего используется метод Function.prototype.call?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#28",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Call</span> используется для привязки определенного объекта к значению this вызываемой функции.</p> <p><img class='question__img' src='img/habr70/28.1habr70.png' alt=''></p> <p>Этот метод похож на <span>Function.prototype.apply</span>. Отличие состоит в том, что в <span>call</span> аргументы передаются через запятую.</p> <p><img class='question__img' src='img/habr70/28.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question: "В чем разница между методами call и apply?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#29",
      linkName: "answer on habr.com",
      answer1:
        "<p>Отличие между <span>call</span> и <span>apply</span> состоит в том, как мы передаем аргументы в вызываемой функции. В <span>apply</span> аргументы передаются в виде массива, в <span>call</span> — через запятую.</p> <p><span>reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15 <br> reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question: "Для чего используется метод Function.prototype.bind?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#30",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Bind</span> возвращает новую функцию, значением <span></span>this которой является объект, указанный в качестве первого параметра. В отличие от <span>bind</span>, <span>call</span> и <span>apply</span> сразу же вызывают функцию.</p> <p><img class='question__img' src='img/habr70/30habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "REACT?",
      image2: "",
    },
  },
  {
    id: 31,
    question:
      "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#31",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Функциональное программирование</span> — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.</p> <p><span>Объект Array</span> содержит методы <span>map</span>, <span>filter</span> и <span>reduce</span>, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.</p> <p><span>Метод map</span> возвращает новый массив с результатами вызова <span>callback</span>callback для каждого элемента массива:</p> <p><span>const words = ['Functional', 'Procedural', 'Object-Oriented']<br>const wordsLength = words.map(word => word.length)</span></p> <p><span>Метод filter</span> создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в <span>callback</span>:</p> <p><img class='question__img' src='img/habr70/31habr70.png' alt=''></p> <p><span>Метод reduce</span> выполняет <span>callback</span> один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего <span>callback</span>), значение текущего элемента, текущий индекс и итерируемый массив:</p> <p><span>const strs = ['I', ' ', 'am', ' ', 'Iron', ' ', 'Man']<br>const result = strs.reduce((acc, currentStr) => acc + str, '')</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "REACT?",
      image2: "",
    },
  },
  {
    id: 32,
    question: "Что такое функции высшего порядка (Higher Order Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#32",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Функция высшего порядка</span> — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.</p> <p><span>function higherOrderFunction(param, callback)<br>{ return callback(param) }</span></p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 33,
    question:
      "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#33",
      linkName: "answer on habr.com",
      answer1:
        "<p>Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 34,
    question: "Как бы Вы реализовали метод Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#34",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Метод map</span> создает новый массив с результатом вызова указанной функции для каждого элемента массива</p> <p><span>Метод map</span> вызывает переданную функцию <span>callback</span> один раз для каждого элемента, в порядке их появления и конструирует новый массив из результатов её вызова</p> <ul> Функция <span>callback</span> вызывается с тремя аргументами: <li>- значение элемента,</li> <li>- индекс элемента,</li> <li>- массив, по которому осуществляется проход.</li> </ul> <p>Следующий код берёт массив чисел и создаёт новый массив, содержащий квадратные корни чисел из первого массива.</p> <p><span>const numbers = [1, 4, 9];<br>const roots = numbers.map(Math.sqrt);<br>// теперь roots равен [1, 2, 3], а numbers всё ещё равен [1, 4, 9]</span></p> <p>Следующий код показывает, как работает отображение, когда функция требует один аргумент. Аргумент будет автоматически присваиваться каждому элементу массива, когда map проходит по оригинальному массиву.</p> <p><span>const numbers = [1, 4, 9];<br>const doubles = numbers.map((num) => num * 2);<br>// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },

  {
    id: 35,
    question: "Как бы Вы реализовали метод Array.prototype.filter?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#35",
      linkName: "answer on habr.com",
      answer1:
        "<p>Метод<span>filter() создаёт новый массив со всеми элементами</span>, прошедшими проверку, задаваемую в передаваемой функции.</p> <p><span>Метод filter()</span>вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, и создаёт новый массив со всеми значениями, для которых функция callback вернула значение, которое может быть приведено к true.</p> <ul> Функция <span>callback</span> вызывается с тремя аргументами: <li>- значение элемента,</li> <li>- индекс элемента,</li> <li>- массив, по которому осуществляется проход.</li> </ul> <p>Следующий пример использует <span>filter()</span> для создания отфильтрованного массива, все элементы которого больше или равны 10, а все меньшие 10 удалены.</p> <p><img class='question__img' src='img/habr70/35habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 36,
    question: "Как бы Вы реализовали метод Array.prototype.reduce?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#36",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Метод reduce</span> применяет функцию <span>reducer</span> к каждому элементу массива (слева-направо), возвращая одно результирующее значение.</p> <p>Подробнее смотри <a class='question__link' href='https://habr.com/ru/articles/486820/' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 37,
    question: "Что такое объект arguments?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#37",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Arguments</span>— это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции.</p> <p>Преобразовать <span>arguments</span> в массив можно с помощью <span>Array.prototype.slice</span>: <br> <span>Array.prototype.slice.call(arguments)</span>.</p> <p><span>Запомните</span>: в стрелочных функциях объект arguments не работает.</p> <p><img class='question__img' src='img/habr70/37habr70.png' alt=''></p> <p>Вызов функции four приводит к ошибке <span>ReferenceError: arguments is not defined.</span> Эту проблему можно решить с помощью оператора <span>rest</span>:</p> <p><span>const four = (...args) => args</span></p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 38,
    question: "Как создать объект, не имеющий прототипа?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#38",
      linkName: "answer on habr.com",
      answer1: "<p>Это можно сделать с помощью <span>Object.create</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 39,
    question:
      "Почему в представленном коде переменная b становится глобальной при вызове функции?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#39",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 40,
    question: "Что такое ECMAScript?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#40",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>ECMAScript</span>— это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения <span>ECMAScript</span> отражаются на JS.</p> <p>Последний вариант спецификации <span>ECMA-262</span>  можно посмотреть<a class='question__link' href='https://ecma-international.org/publications-and-standards/standards/ecma-262/' target='_blank' rel='noopener noreferrer'>здесь.</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 41,
    question: "Что нового привнес в JS стандарт ES6 или ECMAScript2015?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#41",
      linkName: "answer on habr.com",
      answer1:
        " <p>1. Стрелочные функции (Arrow Functions).</p> <p>2. Классы (Classes).</p> <p>3. Шаблонные строки (Template Strings).</p> <p>4. Расширенные объектные литералы (Enhanced Object pterals).</p> <p>. 5Деструктуризация (Object Destructuring).</p> <p>6. Промисы (Promises).</p> <p>7. Генераторы (Generators).</p> <p>8. Модули (Modules).</p> <p>9. Symbol.</p> <p>10. Прокси (Proxies).</p> <p>11. Множества (Sets).</p> <p>12. Параметры по умолчанию.</p> <p>13. Операторы rest и spread.</p> <p>14. Блочная область видимости (ключевые слова «let» и «const»).</p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 42,
    question: "В чем разница между ключевыми словами «var», «let» и «const»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#42",
      linkName: "answer on habr.com",
      answer1:
        "<p>Переменные, объявленные с помощью ключевого слова <span>«var»</span>, являются глобальными. Это означает, что они доступны из любого места в коде.</p> <p>Переменные, объявленные с помощью ключевых слов <span>«let»</span> и <span>«const»</span> имеют блочную область видимости. Это означает, что они доступны только внутри блока <span>({ })</span>.</p> <p>Разница между <span>«let»</span> и <span>«const»</span> состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью <span>const</span>, но не само свойство (переменную).</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 43,
    question: "Что такое стрелочные функции (Arrow Functions)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#43",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Стрелочная функция</span>— это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово <span>«function»</span>:</p>  <p><span>const getCurrentDate = () => new Date().</span></p> <p>В <span>функциональном выражении</span>мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение:</p> <p><span>function greet(name){ return 'Hello ' + name + '!' } // ES5</span></p> <p><span>const greet = (name) => `Hello ${name}`<br>const greet2 = name = > `Hello ${name}`<br>// ES6</span></p> <p>Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:</p> <p></p>  <span>const getArgs = () => arguments<br>const getArgs2 = (...rest) => rest</span> <p>У стрелочных функций нет доступа к объекту <span>arguments</span>. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор <span>rest</span>.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 44,
    question: "Что такое классы (Classes)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#44",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Классы</span> — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование.</p> <p><img class='question__img' src='img/habr70/44.1habr70.png' alt=''></p> <p><img class='question__img' src='img/habr70/44.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 45,
    question: "Что такое шаблонные литералы (Template Literals)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#45",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Шаблонные литералы</span> — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``)</p> <p><img class='question__img' src='img/habr70/45habr70.png' alt=''></p> <p>В ES6 нам не нужно использовать конкатенацию строк для объединения текста с переменной: мы можем использовать выражение <span>${expr}</span> для получения значения переменной.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 46,
    question: "Что такое деструктуризация объекта (Object Destructuring)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#46",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Деструктуризация</span> — относительно новый способ получения (извлечения) значений объекта или массива.</p> <p>Допустим, у нас есть такой объект:</p> <p><span>const employee = {   <br>firstName: 'Marko',<br> lastName: 'Polo',<br> position: 'Software Developer',<br> yearHired: 2017<br>}</span></p> <p>Раньше для получения свойств объекта мы создавали переменные для каждого свойства. Это было очень скучно и сильно раздражало:</p> <p><span>var firstName = employee.firstName<br>var lastName = employee.lastName<br>var position = employee.position<br>var yearHired = employee.yearHired</span></p> <p>Использование <span>деструктуризации</span> позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства <span>объекта</span>, которые хотим получить, в фигурные скобки <span>({ })</span>, а если речь идет о <span>массиве</span> — в квадратные скобки <span>([ ])</span>:</p> <p><span>let { firstName, lastName, position, yearHired } = employee</span></p> <p>Для изменения имени переменной следует использовать <span>«propertyName: newName»</span>:</p>  <p><span>let { firstName: fName, lastName: lName, position, yearHired } = employee</span></p> <p>Для присвоения переменным значения по умолчанию следует использовать <span>«propertyName = 'defaultValue'»</span>:</p> <p><span> let { firstName = 'Mark', lastName: lName, position, yearHired } = employee</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 47,
    question: "Что такое модули (Modules)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#47",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Модули</span> позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле.</p> <p>Синтаксис модулей очень простой: мы используем <span>import</span> для импорта функциональности или значений из другого файла или файлов и <span>export</span> для экспорта</p> <p>До появления модулей в JS существовало две популярные системы модулей для поддержки кода:</p> <p>1. CommonJS — Nodejs.</p> <p>2. AMD (AsyncronousModuleDefinition) — Browsers.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 48,
    question: "Что такое объект Set?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#48",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Объект Set</span> позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в <span>Set</span> можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма <span>SameZeroValue</span>.</p> <p><span>Экземпляр Set</span> создается с помощью <span>конструктора Set</span>. Мы также можем передать ему некоторые значения при создании:</p> <p><span>const set1 = new Set()<br>const set2 = new Set(['a','b','c','d','d','e']) // вторая 'd' не добавится</span></p> <p>Его основные методы это:</p> <ul> <li>- new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.</li> <li>- set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.</li> <li>- set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.</li> <li>- set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.</li> <li>- set.clear() – удаляет все имеющиеся значения.</li> <li>- set.size – возвращает количество элементов в множестве.</li> </ul> <p>Подробнее смотри<a class='question__link' href='https://learn.javascript.ru/map-set' target='_blank' rel='noopener noreferrer'>здесь.</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 49,
    question: "Что такое функция обратного вызова (Callback Function)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#49",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Функция обратного вызова</span> — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события).</p> <p><span>Колбэк-функция (или обратный вызов)</span> - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.</p> <p>Вот краткий пример <span>синхронного колбэка</span>, поскольку функция <span>processUserInput</span> выполняется <span>синхронно:</span></p> <p><img class='question__img' src='img/habr70/49.1habr70.png' alt=''></p> <p>Колбэки часто используются для продолжения выполнения кода после завершения <span>асинхронной операции</span> - они называются <span>асинхронными колбэками.</span>Пример:</p> <p><img class='question__img' src='img/habr70/49.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 50,
    question: "Что такое промисы (Promises)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#50",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Promise (промис)</span> - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.</p> <p>В сущности, <span>промис</span> - это возвращаемый объект, в который вы записываете два колбэка вместо того, чтобы передать их функции.</p> <p><img class='question__img' src='img/habr70/50.1habr70.png' alt=''></p> <ul> У промиса есть четыре состояния: <li><span>Ожидание (pending)</span> — начальное состояние промиса, не исполнен и не отклонён.. Результата промиса неизвестен, поскольку операция не завершена.</li> <li><span>Выполнено (fulfilled)</span> — асинхронная операция выполнена, имеется результат. Операция завершена успешно.</li> <li><span>Отклонено (rejected)</span> — асинхронная операция не выполнена, имеется причина. Операция завершена с ошибкой.</li> <li><span>Завершено</span> — выполнено или отклонено.</li>  </ul> <p>При создании промис находится в <span>ожидании (pending)</span>, а затем может стать <span>исполненным (fulfilled)</span>, вернув полученный <span>результат (значение)</span>, или <span>отклонённым (rejected)</span>, вернув причину отказа. В любом из этих случаев вызывается обработчик, прикреплённый к промису <span>методом then</span>. (Если в момент назначения обработчика промис уже исполнен или отклонён, обработчик всё равно будет вызван, т.е. асинхронное исполнение промиса и назначение обработчика не будет происходить в «состоянии гонки», как, например, в случае с событиями в DOM.)</p> <p>В качестве параметров конструктор промиса принимает <span>resolve </span>и <span>reject</span>. В <span>resolve</span> записывается результат выполнения операции, в <span>reject</span> — причина невыполнения операции. Результат может быть обработан в методе <span>.then</span>, ошибка — в методе <span>.catch</span>. Метод <span>.then</span> также возвращает <span>промис</span>, поэтому мы можем использовать цепочку, состоящую из нескольких <span>.then</span>.</p> <p><img class='question__img' src='img/habr70/50.2habr70.png' alt=''></p> <p>Подробнее о промисах можно почитать <a class='question__link' href='https://learn.javascript.ru/promise-basics' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 51,
    question: "Что такое async/await?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#51",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Async/await</span> — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова. Однако для использования async/await необходимо хорошо знать промисы.</p> <p><img class='question__img' src='img/habr70/51.1habr70.png' alt=''></p> <p><span>Запомните</span>: использование ключевого слова <span>«async»</span> перед функцией заставляет ее возвращать <span>промис</span>:</p> <p><img class='question__img' src='img/habr70/51.2habr70.png' alt=''></p> <p>Ключевое слово «await» можно использовать только внутри асинхронной функции. Использование «await» внутри другой функции приведет к ошибке. Await ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.</p> <p><img class='question__img' src='img/habr70/51.3habr70.png' alt=''></p> <p>Подробнее о промисах можно почитать <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/async_function' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://learn.javascript.ru/async-await' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 52,
    question: "В чем разница между spread-оператором и rest-оператором?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#52",
      linkName: "answer on habr.com",
      answer1: "<p><span>ИСКАТЬ В ИНЕТЕ</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2:
        "<p>Операторы <span>spread</span> и <span>rest</span> имеют одинаковый синтаксис <span>('...')</span>. Разница состоит в том, что с помощью <span>spread</span> мы передаем или распространяем данные массива на другие данные, а с помощью <span>rest</span> — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров).</p> <p><span>Оператор spread</span> — это конструкция в JavaScript, которая позволяет передавать элементы массива или свойства объекта в виде отдельных аргументов.</p> <p><span>Spread syntax</span>позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах</p> <ul> <li>для функций: где ожидаемое количество аргументов для вызовов функций равно нулю или больше нуля;</li> <li>для элементов (литералов массива);</li> <li>для выражений объектов: в местах, где количество пар 'ключ-значение' должно быть равно нулю или больше (для объектных литералов);</li> </ul> <p><img class='question__img' src='img/habr70/52.1habr70.png' alt=''></p> <p><span>Оператор rest</span> — это синтаксическая конструкция в JavaScript, которая позволяет собирать оставшиеся элементы массива в другой массив или собирать оставшиеся свойства объекта в другой объект. Он всегда идёт последним и может использоваться только раз при одной операции «распаковки» массива или объекта.</p> <p><img class='question__img' src='img/habr70/52.2habr70.png' alt=''></p>",
      image2: "",
    },
  },
  {
    id: 53,
    question: "Что такое параметры по умолчанию (Default Parameters)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#53",
      linkName: "answer on habr.com",
      answer1:
        "<p>Это относительно новый способ определения значений переменных по умолчанию.</p> <p>В приведённом ниже примере, в случае если при вызове функции значение для параметра <span>b</span> не передавалось, его значением становилось <span>undefined</span>, и результатом вычисления <span>a * b</span> в функции <span></span> получалось значение <span>NaN</span>.</p> <p><img class='question__img' src='img/habr70/53.1habr70.png' alt=''></p> <p>Чтобы такого не происходило, в теле функции использовался код подобный тому, что находится во второй строчке, где в случае, если функция <span>multiply</span> вызывалась только c одним аргументом, параметру <span>b</span> присваивалось значение <span>1</span>:</p> <p><img class='question__img' src='img/habr70/53.2habr70.png' alt=''></p> <p>С появлением в ES2015 параметров по умолчанию стало возможным обходиться без проверки параметров в теле функции. Так, в приведённом выше примере достаточно в заголовке функции указать <span>1</span> в качестве значения по умолчанию для параметра <span>b</span>:</p> <p><img class='question__img' src='img/habr70/53.3habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 54,
    question: "Что такое объектная обертка (Wrapper Objects)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#54",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 55,
    question:
      "В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#55",
      linkName: "answer on habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 56,
    question: "Что такое NaN? Как проверить, является ли значение NaN?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#56",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>NaN</span> или <span>Not A Number (не число)</span> — это значение, получаемое в результате выполнения числовой операции над нечисловым значением</p> <p>В JS есть <span>встроенный метод isNaN</span>, позволяющий проверять, является ли значение <span>NaN</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 57,
    question: "Как проверить, является ли значение массивом?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#57",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для этого следует использовать метод <span>Array.isArray</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 58,
    question:
      "Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора ' % ')?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#58",
      linkName: "answer on habr.com",
      answer1:
        "<p>Для решения данной задачи можно использовать оператор <span>'&' (бинарное и)</span>. <span>Оператор '&'</span> сравнивает операнды как бинарные значения.</p> <p><img class='question__img' src='img/habr70/58.1habr70.png' alt=''></p> <p>0 в бинарной системе счисления это 000, 1 - 001, 2 - 010, 3 - 011, 4 - 100, 5 - 101 и т.д.</p> <p>Console.log(5 & 1) вернет 1. Сначала оператор " &
        " конвертирует оба числа в бинарные значения, 5 превращается в 101, 1 — в 001. Затем производится побитовое сравнение:</p> <p><img class='question__img' src='https://habrastorage.org/r/w1560/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png' alt=''></p> <p>Сравниваем 1 и 0, получаем 0.</p> <p>Сравниваем 0 и 0, получаем 0</p> <p>Сравниваем 1 и 1, получаем 1.</p> <p>Преобразуем бинарное значение в целое число, получаем 1.</p> <p>Если эта информация кажется Вам слишком сложной, мы можем решить поставленную задачу с помощью рекурсивной функции:</p> <p><img class='question__img' src='img/habr70/58.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 59,
    question: "Как определить наличие свойства в объекте?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#59",
      linkName: "answer on habr.com",
      answer1:
        "<p>Существует три способа это сделать.</p> <p><img class='question__img' src='img/habr70/59.1habr70.png' alt=''></p> <p>Первый способ состоит в использовании <span>оператора «in»</span>:</p> <p><img class='question__img' src='img/habr70/59.2habr70.png' alt=''></p> <p>Второй — использовать <span>метод hasOwnProperty</span>:</p> <p>Третий — <span>индексная нотация массива</span>:</p> <p><img class='question__img' src='img/habr70/59.3habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 60,
    question: "Что такое AJAX?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#60",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>AJAX или Asyncronous JavaScript and XML</span> — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы.</p> <ul><span>AJAX</span> использует следующие технологии: <li><span>HTML</span> — структура веб-страницы.</li> <li><span>CSS</span> — стили веб-страницы.</li> <li><span>JavaScript</span> — поведение страницы и работа с DOM.</li> <li><span>XMLHttpRequest API</span> — отправка и получение данных с сервера.</li> <li>PHP, Python, Nodejs — какой-нибудь <span>серверный язык</span>.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 61,
    question: "Как в JS создать объект?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#61",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Объектный литерал:</span></p> <p><img class='question__img' src='img/habr70/61.1habr70.png' alt=''></p> <p><span>Функция-конструктор:</span></p> <p><img class='question__img' src='img/habr70/61.2habr70.png' alt=''></p> <p><span>Метод Object.create:</span></p> <p><img class='question__img' src='img/habr70/61.3habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 62,
    question: "В чем разница между методами Object.freeze и Object.seal?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#62",
      linkName: "answer on habr.com",
      answer1:
        "<p>Разница заключается в том, что при использовании метода <span>Object.freeze</span> мы не можем менять или редактировать свойства объекта, а при использовании <span>Object.seal</span> у нас такая возможность имеется.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 63,
    question: "В чем разница между оператором «in» и методом hasOwnProperty?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#63",
      linkName: "answer on habr.com",
      answer1:
        "<p>Отличие состоит в том, что <span>оператор «in»</span> проверяет наличие свойства не только в самом объекте, но и в его прототипах, а <span>метод hasOwnProperty</span> — только в объекте.</p> <p><img class='question__img' src='img/habr70/63.3habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 64,
    question: "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#64",
      linkName: "answer on habr.com",
      answer1:
        "<p>- Функции обратного вызова (Callbacks).</p> <p>- Промисы (Promises).</p> <p>- Async/await.</p> <p>- Библиотеки вроде async.js, blueprint, q, co.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 65,
    question:
      "В чем разница между обычной функцией и функциональным выражением?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#65",
      linkName: "answer on habr.com",
      answer1:
        "<p>Допустим, у нас есть следующее:</p> <p><img class='question__img' src='img/habr70/65habr70.png' alt=''></p> <p>Вызов <span>notHoistedFunc</span> приведет к ошибке, а вызов <span>hoistedFunc</span> нет, потому что <span>hoistedFunc «всплывает»</span>, поднимается в глобальную область видимости, а <span>notHoistedFunc нет</span>.</p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 66,
    question: "Как в JS вызвать функцию?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#66",
      linkName: "answer on habr.com",
      answer1:
        "<p>В JS существует 4 способа вызвать функцию. Вызов определяет значение this или «владельца» функции.</p> <p><span>Вызов в качестве функции.</span> Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window:</p> <p><img class='question__img' src='img/habr70/66.1habr70.png' alt=''></p> <p><span>Вызов в качестве метода.</span> Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением <span>this</span> становится объект этого метода:</p> <p><img class='question__img' src='img/habr70/66.2habr70.png' alt=''></p> <p><span>Вызов в качестве конструктора.</span> Когда функция вызывается с использованием <span>ключевого слова «new»</span>, мы называем такую функцию <span>конструктором</span>. При этом создается пустой объект, являющийся значением <span>this</span>:</p> <p><img class='question__img' src='img/habr70/66.3habr70.png' alt=''></p> <p><span>Вызов с помощью методов apply или call.</span> Мы используем эти методы, когда хотим явно определить значение <span>this</span> или владельца функции:</p> <p><img class='question__img' src='img/habr70/66.4habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 67,
    question: "Что такое запоминание или мемоизация (Memoization)?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#67",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Мемоизация</span> — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 68,
    question: "Как бы Вы реализовали вспомогательную функцию запоминания?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#68",
      linkName: "answer on habr.com",
      answer1:
        "<p><img class='question__img' src='img/habr70/68.1habr70.png' alt=''></p> <p>Мы реализовали функцию мемоизации с одним аргументом. Сделаем ее «мультиаргументной»:</p> <p><img class='question__img' src='img/habr70/68.2habr70.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 69,
    question:
      "Почему typeof null возвращает object? Как проверить, является ли значение null?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#69",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>typeof null == 'object'</span> всегда будет возвращать <span>true</span> по историческим причинам. Поступало предложение исправить эту ошибку, изменив <span>typeof null = 'object'</span> на <span>typeof null = 'null'</span>, но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок)</p> <p>Для проверки, является ли <span>значение null</span> можно использовать <span>оператор строгого равенства (===)</span>:</p> <p><span>function isNull(value){<br> return value === null<br> }</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 70,
    question: "Для чего используется ключевое слово «new»?",
    answer: {
      href: "https://habr.com/ru/articles/486820/#70",
      linkName: "answer on habr.com",
      answer1:
        "<p><span>Ключевое слово «new»</span> используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).</p> <p>Допустим, у нас есть такой код:</p> <p><img class='question__img' src='img/habr70/70habr70.png' alt=''></p> <ul> Ключевое слово «new» делает 4 вещи: <li>1. Создает пустой объект.</li> <li>2. Привязывает к нему значение this.</li> <li>3. Функция наследует от functionName.prototype.</li> <li></li> <li>4. Возвращает значение this, если не указано иное.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },

  /* ----------------------------- */

  // {
  //   id: 1,
  //   question: "",
  //   answer: {
  //     href: "",
  //     linkName: "",
  //     answer1: "",
  //     image1: "",
  //     href2: "",
  //     linkName2: "",
  //     answer2: "",
  //     image2: "",
  //   },
  // },
];

/* Вопросы для подготовки к собеседованию по JavaScript. Часть 1 */
/* https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18 */
/* разметка сделана */
const questionsJSProglibPart1 = [
  {
    id: 1,
    question: "Какие типы данных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<ul> <li><span>Number</span> – число. Тип Number в JavaScript может хранить как целые числа, так и числа с плавающей точкой.</li> <li><span>BigInt</span> – используется для представления целых чисел произвольной длины, превышающих 2^53 – 1. BigInt создается с помощью добавления n в конец целочисленного литерала или путем вызова функции BigInt(), которая создает BigInt из строк, чисел и т.д.</li> <li><span>String</span> – строка (последовательность символов), например, 'JavaScript – главный язык интернета'.Строки записываются с использованием кавычек, можно использовать одинарные или двойные кавычки.</li> <li><span>Boolean</span> – логический (булев) тип, который может принимать значения true (истина) или false (ложь).</li> <li><span>Object</span> – объект. Это значение в памяти, на которое возможно сослаться с помощью идентификатора. Объект может расцениваться как набор свойств. Значения свойств могут иметь любой тип, включая другие объекты, что позволяет строить сложные, разветвленные иерархии данных.</li> <li><span>Null</span> – специальное значение, которое представляет «ничего», «пусто», или «неизвестное значение».</li> <li><span>Undefined</span> – это значение присваивается переменной, если она была объявлена, но не получила значения.</li> <li><span>Symbol</span> – это уникальный и неизменяемый тип данных, который можно использовать в качестве идентификатора для свойств объекта.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "В чем состоит различие между == и ===?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript операторы == и === используются для сравнения двух значений, но они работают по-разному:</p> <p>== проверяет на <span>абстрактное равенство</span>, то есть он преобразует типы данных перед сравнением – например, если вы сравниваете строку с числом, JavaScript преобразует строку в число перед сравнением. Если строка не может быть преобразована в число, она преобразуется в NaN, что возвращает false. Если оба операнда имеют <span>разные</span> типы данных, но они могут быть преобразованы в один и тот же <span>тип</span> данных и имеют одно и то же <span>значение</span>, оператор== вернетtrue:</p> <p><img class='question__img' src='img/1.1proglibPart1.png' alt=''></p> <p>=== проверяет на <span>строгое равенство</span>, то есть он не выполняет преобразование типов данных. Если два значения имеют разные типы данных, оператор === вернет false, даже если они имеют одно и то же значение. Если оба операнда имеют <span>одинаковый</span> тип данных и <span>одинаковое</span> значение, оператор === вернет true:</p> <p><img class='question__img' src='img/1.2proglibPart1.png' alt=''>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Какие способы объявления переменных есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript есть четыре способа объявления переменных:</p> <p>1. <span>myVariable = 5;</span> – неявное объявление переменной. Оно создает глобальную переменную myVariable и присваивает ей значение 5, что может привести к ошибкам в строгом режиме ('use strict').</p> <p>2. <span>var myVariable = 5;</span> – явное объявление переменной с использованием ключевого слова var. Область видимости переменной myVariable может быть функциональной или глобальной, если она объявлена вне функции. Недостаток var состоит в том, что ее область видимости не ограничивается блоком, в котором используется переменная.</p> <p>3. <span>let myVariable = 5;</span>– явное объявление переменной с использованием ключевого слова let. Область видимости такой переменной ограничивается блоком, в котором она объявлена – на уровне функции она не видна</p> <p>4. <span>const myVariable = 5;</span> – это явное объявление переменной с использованием ключевого слова const. Переменная myVariable объявляется в области видимости блока, как и let. Однако, в отличие от let, переменная myVariable является неизменяемой – ее значение не может быть изменено после объявления, за одним исключением: если значение является объектом или массивом, его свойства или элементы могут быть изменены, но сама переменная все равно остается неизменяемой</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "В чем разница между null и undefined?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript и <span>null</span>, и <span>undefined</span> представляют отсутствие значения, но они используются в разных контекстах и имеют разные семантические значения.</p> <p><span>Undefined</span> – присваивается переменной, когда она объявлена, но ей не присвоено конкретное значение.</p> <p><span>Null</span> – специальное значение, которое представляет «ничего», «пусто» или «неизвестное значение». Присваивается переменной вручную, чтобы указать, что она не должна иметь значения. Например, если нужно очистить значение переменной, можно установить его в null</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Чем стрелочные функции отличаются от обычных?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Стрелочные функции позволяют использовать упрощенный синтаксис при создании небольших функций-обработчиков. У них есть некоторые ограничения по сравнению с обычными функциями:</p> <p><span>Стрелочные функции не могут использовать объект arguments.</span> В обычных функциях этот объект содержит все переданные при вызове аргументы:</p> <p><img class='question__img' src='img/5.1proglibPart1.png' alt=''></p><p><span>У стрелочных функций другой синтаксис записи.</span> Они записываются короче, используя стрелку => и не требуя ключевого слова function:</p> <p><img class='question__img' src='img/5.2proglibPart1.png' alt=''></p> <p><span>У стрелочных функций нет собственного контекста this.</span> Вместо этого контекст берется из внешней области видимости:</p> <p><img class='question__img' src='img/5.3proglibPart1.png' alt=''></p> <p><span>Стрелочные функции нельзя использовать как конструкторы с ключевым словом new.</span> То есть, из них нельзя создавать объекты при помощи оператора new:</p> <p><img class='question__img' src='img/5.4proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Что такое замыкание?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p><span>Замыкание (closure)</span> в JavaScript – это комбинация функции и лексического окружения, в котором эта функция была определена. Такая функция имеет доступ к переменным внешней функции, даже после того, как внешняя функция завершила выполнение</p> <p><img class='question__img' src='img/6proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое шаблонные строки (литералы)?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p><span>Шаблонные строки (template literals)</span>в JavaScript – это новый способ работы со строками, введенный в ECMAScript 6 (ES6). Они обозначаются обратными кавычками ` вместо одинарных или двойных кавычек. Шаблонные строки позволяют создавать многострочные строки без необходимости использования специальных символов или конкатенации строк:</p> <p><img class='question__img' src='img/7.1proglibPart1.png' alt=''></p> <p>Шаблонные строки также поддерживают интерполяцию строк, что позволяет вставлять выражения прямо в строку. Эти выражения заключаются в фигурные скобки ${expression} и вычисляются при создании строки:</p> <p><img class='question__img' src='img/7.2proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Что такое Map и Set в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Map и Set – это два типа коллекций, которые были введены в ECMAScript 6 (ES6). Они предоставляют более гибкие и мощные способы работы с наборами данных по сравнению с обычными объектами и массивами.</p> <p><span>Map</span> – это коллекция, которая состоит из пар <span>ключ-значение</span>, подобно объектам. Основное отличие Map от объектов заключается в том, что Map запоминает порядок добавления пар и позволяет использовать в качестве ключей данные любых типов:</p> <p><img class='question__img' src='img/8.1proglibPart1.png' alt=''></p> <p>При желании в <span>Map</span> в качестве ключей можно использовать функции:</p> <p><img class='question__img' src='img/8.2proglibPart1.png' alt=''></p> <p><span>Set</span> – это множество, в котором каждое значение может появляться только один раз. Дубликатов в <span>Set</span> нет:</p> <p><img class='question__img' src='img/8.3proglibPart1.png' alt=''></p> <p>Подробнее смотри<a class='question__link' href='https://learn.javascript.ru/map-set' target='_blank' rel='noopener noreferrer'>здесь.</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Как проверить наличие свойства в объекте?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript есть два основных способа проверить наличие свойства в объекте – метод hasOwnProperty и оператор in.</p> <p>Метод <span>hasOwnProperty()</span> возвращает <span>true</span>, если указанное свойство является прямым свойством объекта, и <span>false</span> в противном случае. Этот метод не проверяет свойства в цепочке прототипов объекта. Оператор <span>in</span> возвращает <span>true</span>, если указанное свойство существует в объекте, независимо от того, является ли оно собственным свойством или унаследовано:</p> <p><img class='question__img' src='img/9proglibPart1.png' alt=''></p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Как получить доступ к свойствам объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript есть два основных способа доступа к свойствам объекта: <span>статический</span> (с использованием точечной нотации) и <span>динамический</span> (с использованием квадратных скобок).</p> <p>Точечная нотация позволяет напрямую получить доступ к свойству объекта, используя <span>имя</span> свойства. Скобочная нотация позволяет динамически получить доступ к свойству объекта с использованием квадратных скобок:</p> <p><img class='question__img' src='img/10.1proglibPart1.png' alt=''></p> <p>Скобочная нотация использует интерполяцию и особенно полезна, если имя свойства неизвестно заранее или когда оно хранится в переменной:</p> <p><img class='question__img' src='img/10.2proglibPart1.png' alt=''></p>  ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Какие основные методы работы с массивами есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Oсновные методы для работы с массивами – <span>forEach</span>, <span>filter</span>, <span>map</span> и <span>reduce</span>.</p> <p>Метод <span>forEach</span> выполняет функцию для каждого элемента в массиве. Он не возвращает ничего, но позволяет выполнять действия с каждым элементом массива.  Применяется, когда нужно выполнить некоторые операции над каждым элементом, но не нужно создавать новый массив:</p> <p><img class='question__img' src='img/11.1proglibPart1.png' alt=''></p> <p>Метод <span>filter</span> создает новый массив, включающий только те элементы исходного массива, для которых функция обратного вызова возвращает <span>true</span>. Используется, когда нужно отфильтровать массив, чтобы включить только определенные элементы:</p> <p><img class='question__img' src='img/11.2proglibPart1.png' alt=''></p> <p>Метод <span>map</span> создает новый массив, который состоит из результатов применения функции к каждому элементу исходного массива. Применяется, когда нужно преобразовать каждый элемент массива:</p> <p><img class='question__img' src='img/11.3proglibPart1.png' alt=''></p> <p>Метод <span>reduce</span> выполняет функцию для каждого элемента массива, накапливая результат в одном значении. Используется, когда нужно объединить все элементы массива в одно значение, например, вычислить сумму всех чисел в массиве</p> <p><img class='question__img' src='img/11.4proglibPart1.png' alt=''></p> <p>Статья по теме: <a class='question__link' href='https://proglib.io/p/metody-massivov-v-javascript-dlya-novichkov-sovety-rekomendacii-i-primery-2022-04-26' target='_blank' rel='noopener noreferrer'>Методы массивов в JavaScript для новичков: советы, рекомендации и примеры</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Какие способы создания объектов есть в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p> Объекты JavaScript создаются с помощью функции-конструктора, литеральной нотации объекта, класса и метода <span>Object.create()</span>.</p> <p><span>Функция-конструктор</span> – это специальная функция, которую можно использовать для создания объектов с определенными свойствами и методами. Функция-конструктор используется с ключевым словом <span>new</span>:</p> <p><img class='question__img' src='img/12.1proglibPart1.png' alt=''></p> <p><span>Литеральная нотация</span> объекта позволяет создать объект, указав его свойства и значения внутри фигурных скобок <span>{}</span>:</p> <p><img class='question__img' src='img/12.2proglibPart1.png' alt=''></p> <p><span>Классы</span> позволяют создавать объекты с помощью синтаксиса, похожего на классы в других языках программирования:</p> <p><img class='question__img' src='img/12.3proglibPart1.png' alt=''></p> <p><span>Метод Object.create()</span> позволяет создать новый объект, используя существующий объект в качестве прототипа для нового объекта. Этот метод принимает два аргумента: прототип и объект свойств. Объект свойств определяет свойства нового объекта и их атрибуты <span>configurable</span>, <span>enumerable</span>, <span>writable</span> и <span>value</span>:</p> <p><img class='question__img' src='img/12.4proglibPart1.png' alt=''></p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Что такое Promise (промис)?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p><span>Промис (Promise)</span> — специальный объект JavaScript, который используется для написания и обработки асинхронного кода. Он имеет три состояния:</p> <ul> <li><span>pending</span> – начальное состояние, означает, что асинхронная операция еще не завершена.</li> <li><span>fulfilled</span> – операция успешно завершена.</li> <li><span>rejected</span> – операция завершена с ошибкой.</li> </ul> <p>Промисы создаются с помощью конструктора <span>new Promise()</span>. Этот конструктор принимает в качестве аргумента функцию, которая выполняет асинхронную операцию. Функция принимает два аргумента <span>resolve</span> и <span>reject</span>, которые используются для изменения состояния промиса. Если асинхронная операция завершена успешно, вызывается <span>resolve</span>, если произошла ошибка, вызывается <span>reject</span>:</p> <p><img class='question__img' src='img/13.1proglibPart1.png' alt=''></p> <p> Промисы позволяют обрабатывать результаты асинхронных операций, используя методы <span>.then()</span> и <span>.catch()</span>. Метод <span>.then()</span> принимает два аргумента: функцию обратного вызова, которая будет вызвана при успешном выполнении промиса, и функцию обратного вызова, которая будет вызвана при ошибке. Метод <span>.catch()</span> используется для обработки ошибок, которые могут произойти при выполнении промиса:</p> <p><img class='question__img' src='img/13.2proglibPart1.png' alt=''></p> <p> Промисы можно связывать в цепочки, что позволяет выполнять несколько асинхронных операций последовательно. Для этого результат каждого промиса передается в следующий промис в цепочке. Это делается с помощью метода <span>.then()</span>:</p> <p><img class='question__img' src='img/13.3proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "Что такое async/await и как они используются?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p><span>Async/await</span> – это синтаксис JavaScript, который облегчает работу с промисами. Ключевое слово <span>async</span> перед функцией означает, что функция всегда возвращает промис. Ключевое слово <span>await</span> используется внутри асинхронных функций и заставляет JavaScript ожидать, пока промис не будет выполнен, прежде чем продолжить выполнение кода:</p> <p><img class='question__img' src='img/14.1proglibPart1.png' alt=''></p> <p>Надо отметить, что <span>await</span> нельзя использовать вне асинхронной функции. Например, этот код приведет к ошибке:</p> <p><img class='question__img' src='img/14.2proglibPart1.png' alt=''></p> <p>Чтобы решить эту проблему, можно обернуть вызов в другую асинхронную функцию:</p> <p><img class='question__img' src='img/14.3proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "Как проверить, является ли объект массивом?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Для такой проверки можно использовать встроенный метод <span>Array.isArray()</span>. Этот метод принимает объект в качестве аргумента и возвращает <span>true</span>, если объект является массивом, и <span>false</span> в противном случае:</p> <p><img class='question__img' src='img/15proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Что делает оператор расширения?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Оператор расширения <span>...</span> разворачивает итерируемые элементы в отдельные элементы, что удобно для передачи аргументов, объединения массивов/объектов и добавления новых свойств в объекты. Используется: </p> <p>1. В функциях, где ожидаемое количество аргументов для вызова равно нулю или более</p> <p><img class='question__img' src='img/16.1proglibPart1.png' alt=''></p> <p>2. В литералах массива</p> <p><img class='question__img' src='img/16.2proglibPart1.png' alt=''></p> <p>3. В литералах объекта, где количество пар ключ-значение должно быть равно нулю или более</p> <p><img class='question__img' src='img/16.3proglibPart1.png' alt=''></p> <p>4. Для преобразования pстроки в массив символов</p> <p><img class='question__img' src='img/16.4proglibPart1.png' alt=''></p> <p> 5. Для преобразования числа в массив цифр и наоборот</p> <p><img class='question__img' src='img/16.5proglibPart1.png' alt=''></p> <p>6. Для копирования объектов</p> <p><img class='question__img' src='img/16.6proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Как выполняется клонирование объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Если объект не содержит вложенных объектов, как в приведенном ниже примере, для клонирования можно использовать оператор расширения <span>...</span> или метод <span>Object.assign()</span>:</p> <p><img class='question__img' src='img/17.1proglibPart1.png' alt=''></p> <p>Если объект содержит вложенные объекты, нужно выполнить глубокое копирование. Относительно медленный вариант – с использованием <span>JSON</span>:</p> <p><img class='question__img' src='img/17.2proglibPart1.png' alt=''></p> <p>Другой вариант – с использованием метода <span>cloneDeep</span> из библиотеки <span>lodash</span>:</p> <p><img class='question__img' src='img/17.3proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Как изменить контекст функции?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Изменить контекст функции можно с помощью методов <span>bind()</span>, <span>call()</span> и <span>apply()</span>.</p> <p>Метод <span>bind()</span> возвращает новую функцию с привязанным контекстом:</p> <p><img class='question__img' src='img/18.1proglibPart1.png' alt=''></p> <p>Метод <span>call() </span>принимает последовательность аргументов, а <span>apply()</span> принимает массив аргументов в качестве второго параметра:</p> <p><img class='question__img' src='img/18.2proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что такое тернарный оператор и как он работает?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p>Тернарный оператор – это сокращенная форма записи <span>if-else</span>. Он называется тернарным, потому что является единственным оператором в JavaScript, который принимает <span>три</span> аргумента. Синтаксис тернарного оператора:</p> <p><span>условие ? выражение_если_истинно : выражение_если_ложно</span></p> <p>Условие – любое условие, которое возвращает <span>true</span> или <span>false</span>.</p> <p>Выражение для истинного условия – что нужно вернуть, если условие истинно.</p> <p>Выражение для ложного условия – что нужно вернуть, если условие ложно.</p>",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Что такое деструктуризация?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-1-2023-12-18",
      linkName: "proglib.io",
      answer1:
        "<p><span>Деструктуризация</span> в JavaScript позволяет извлечь данные из массива или свойства объекта и присвоить их отдельным переменным. Деструктуризация удобна тем, что позволяет не писать лишний код для доступа к данным внутри объектов/массивов по индексам или ключам.</p> <p><span>Деструктуризация массива:</span></p> <p><img class='question__img' src='img/20.1proglibPart1.png' alt=''></p> <p><span>Деструктуризация объекта:</span></p> <p><img class='question__img' src='img/20.2proglibPart1.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

/* Вопросы для подготовки к собеседованию по JavaScript. Часть 2 */
/* https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12 */
/* разметка сделана */
const questionsJSProglibPart2 = [
  {
    id: 21,
    question: "Что такое DOM?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>DOM</span>  (Document Object Model) – это модель, которая представляет HTML-документ в виде <span>дерева тегов</span>. Каждый HTML-тег в этом дереве является объектом. Вложенные теги являются дочерними элементами по отношению к своему родительскому элементу. Текст внутри тега также является объектом. Все эти объекты доступны для любых манипуляций с помощью JavaScript, а эти манипуляции, в свою очередь, позволяют динамически управлять содержимым страницы.</p> <p>Статья по теме: <a class='question__link' href='https://proglib.io/p/dom-chto-takoe-obektnaya-model-dokumenta-prostymi-slovami-2022-02-18' target='_blank' rel='noopener noreferrer'>DOM: что такое объектная модель документа простыми словами</a></p> <p><img class='question__img' src='img/21proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "Что такое цикл событий?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Цикл событий</span> в JavaScript – это механизм, который управляет выполнением кода. Он обеспечивает обработку событий и выполнение задач в правильном порядке. Хотя JavaScript работает в однопоточной среде, цикл событий дает возможность обрабатывать асинхронные операции и предотвращает блокировку основного потока выполнения.</p> <p>Когда асинхронная операция (например, запрос к серверу) завершается, она помещает соответствующее событие в очередь событий. Цикл событий обрабатывает задачи в порядке их поступления. Он берет событие из очереди и передает его для выполнения. Если событие содержит обратный вызов или обработчик – вызывается соответствующая функция для выполнения кода, связанного с этим событием. Цикл событий также обрабатывает задачи, связанные с таймерами и промисами. Благодаря циклу событий, JavaScript быстро реагирует на действия пользователя и эффективно использует ресурсы при работе с асинхронными операциями.</p> <p>В приведенном ниже примере, несмотря на то, что setTimeout(firstTask, 0) имеет время ожидания0 секунд, первая задача firstTask()все равно не будет выполнена сразу после secondTask(). Это происходит потому, что JavaScript использует цикл событий для управления выполнением асинхронных операций. Когда мы вызываем setTimeout(), функция firstTask() помещается в очередь событий, – цикл событий начинает обрабатывать эту функцию, когда стек вызовов опустеет.</p> <p><img class='question__img' src='img/22proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "Что такое прототипное наследование?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Прототипное наследование </span>в JavaScript – это механизм, который позволяет одному объекту наследовать свойства и методы другого объекта. Это основной способ наследования в JavaScript.</p> <p>Каждый объект в JavaScript имеет внутреннее скрытое свойство prototype, которое ссылается на другой объект. Этот другой объект называется прототипом первого объекта. При попытке получить доступ к свойству объекта, JavaScript сначала проверяет, есть ли это свойство в самом объекте. Если нет, он ищет его в прототипе объекта. Если и там его нет, то в прототипе прототипа и так далее. Если свойство или метод отсутствуют в объекте и его прототипе, JavaScript вернет undefined</p><p><img class='question__img' src='img/23proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question: "Для чего нужен оператор опциональной последовательности?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Оператор опциональной последовательности ?. позволяет получить безопасный доступ к вложенным свойствам объекта – даже в том случае, когда промежуточное свойство отсутствует. Оператор ?.прекращает оценку и возвращаетundefined, если часть после ?. является либоundefined, либо null.</p> <p><img class='question__img' src='img/24proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "Что такое теневой DOM?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Shadow DOM</span> – это техника, позволяющая создавать изолированные фрагменты HTML и CSS в специальном сегменте DOM, который находится внутри определенного элемента. Такой подход позволяет исключить влияние инкапсулированных стилей на структуру и внешний вид основной страницы, и обеспечивает большую гибкость и контроль над представлением и поведением элементов.</p> <p>В приведенном ниже примере инкапсулированные стили пользовательского элемента не влияют на внешний вид остальной части страницы</p>  <p><img class='question__img' src='img/25proglibPart2.png' alt=''></p> <img class='question__img' src='https://media.proglib.io/posts/2024/01/10/9a73b0cff11a40d5727227b04360a489.png' alt=''>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 26,
    question: "Что такое рекурсия и как ее можно использовать в JavaScript?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Рекурсия</span>  в программировании – это процесс, в котором функция вызывает саму себя. Рекурсия обычно используется для решения задач, которые можно разбить на более простые подзадачи. В JavaScript рекурсию можно использовать, например, для работы с многоуровневыми массивами и обхода деревовидных структур данных.</p> <p>Так можно преобразовать вложенный массив в одномерный:</p> <p><img class='question__img' src='img/26.1proglibPart2.png' alt=''></p> <p>А так можно обойти и визуализировать дерево:</p> <p><img class='question__img' src='img/26.2proglibPart2.png' alt=''></p> <p>Результат: <img class='question__img' src='https://media.proglib.io/posts/2024/01/10/72020711c8a0f0f9bd59c96d88bfebb6.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question:
      "В чем разница между объявлением функции и функциональным выражением?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Объявление функции и функциональное выражение</span> – это два способа определения функций в JavaScript.</p> <p><span>Объявление функции</span>  – это традиционный способ определения функции. Функция создается и присваивается переменной, как любое другое значение. При этом объявленные функции доступны во всем коде, даже до того, как программа достигает того участка, где они определены.</p> <p><img class='question__img' src='img/27.1proglibPart2.png' alt=''></p> <p><span>Функциональное выражение</span>  – это альтернативный способ определения функции:</p> <p><img class='question__img' src='img/27.2proglibPart2.png' alt=''></p> <p>В отличие от традиционной функции, функциональное выражение <span>нельзя</span> вызывать до определения в коде – это приведет к ошибке . Функциональные выражения могут:</p> <ul> <li>быть анонимными;</li> <li>формировать замыкания;</li> <li>передаваться в качестве аргументов другим функциям;</li> <li>использоваться как немедленно вызываемые функциональные выражения (IIFE).</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "Что такое функции-конструкторы?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>онструкторы в JavaScript – это специальные функции, используемые для создания объектов. Вот два основных правила при работе с конструкторами:</p> <ul> <li>Имя конструктора должно начинаться с заглавной буквы.</li> <li>Конструктор вызывается при помощи оператора new.</li> </ul> <p>Когда мы вызываем конструктор через new, происходит следующее:</p> <ul> <li>Создается новый пустой объект и присваивается в this.</li> <li>Выполняется код внутри конструктора. Обычно он модифицирует объектthis, добавляя в него свойства.</li> <li>Значение this возвращается из конструктора как результат.</li> </ul> <p>Например: <img class='question__img' src='img/28proglibPart2.png' alt=''></p> <p>Здесь User – функция-конструктор. Когда мы вызываем конструктор через new User('Вася'), создается объект userс указанным именем и методом sayHi. Таким образом с помощью конструкторов можно многократного создавать объекты по одному шаблону.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question: "Как получить список ключей и значений объекта?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript для получения списка ключей и значений объекта используются методы<span>Object.keys() и Object.values()</span>.</p>  <p><span>Object.keys()</span> возвращает массив со всеми ключами объекта:</p> <p><img class='question__img' src='img/29.1proglibPart2.png' alt=''></p> <p><span></span></p> <p><img class='question__img' src='img/29.2proglibPart2.png' alt=''></p> <p>Используя Object.keys() и Object.values(), можно сделать перебор:</p> <p><img class='question__img' src=''img/29.3proglibPart2.png' alt=''></p> <p>Или вывести ключи и значения в виде объекта:</p> <p><img class='question__img' src=''img/29.4proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question:
      "Приведите примеры нововведений, добавленных в JavaScript в версии ES6",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "p>В ES6 множество <a class='question__link' href='https://www.w3schools.com/js/js_es6.asp' target='_blank' rel='noopener noreferrer'>нововведений, dот всего несколько примеров.</a></p> <ul> <li>Деструктуризация объектов: const user = { name: 'Алиса',  age: 20 }; const {name, age} = user; // name = 'Алиса'; age = 20 </li> <li>Деструктуризация массивов: const array = [1, 2, 3]; let [x, y] = array; // x = 1; y = 2</li> <li>Шаблонные строки: const name = 'Инна'; console.log(`Привет, ${name}!`); // Привет, Инна!</li> <li>Стрелочные функции: const sum = (a, b) => a + b; console.log(sum(1, 2)); // 3</li> <li>Параметры по умолчанию: function volume(x = 1, y = 2, z = 3) { return x * y * z; } volume(); // 6 volume(2); // 12</li> <li></li> <li>Объявление переменных с помощью let и const. let – аналог var, но с блочной областью видимости. const – объявление константы (переменной, которую нельзя изменить).</li> <li>Оператор распространения (позволяет распаковывать элементы массива или объекта для аргументов функции или создания новых массивов/объектов): const obj1 = { a: 1, b: 2 }; const obj2 = { c: 3, d: 4 }; const merged = { ...obj1, ...obj2 }; console.log(merged); // { a: 1, b: 2, c: 3, d: 4 }</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 31,
    question: "Как происходит наследование классов в ES6?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Наследование классов в ES6</span> осуществляется с помощью ключевого слова extends, которое следует за именем родительского класса. Родительский класс часто называют базовым классом, а класс, который наследует базовый/родительский класс, называется производным или дочерним</p> <p><img class='question__img' src='img/31proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 32,
    question: "Что такое микрозадачи и макрозадачи?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript микрозадачи и макрозадачи относятся к типам задач, которые должны выполняться в цикле событий.</p> <p><span>Микрозадачи</span> – это задачи, которые должны быть выполнены в текущем цикле событий <span>перед</span> тем, как браузер перерисует страницу. Они обычно добавляются в очередь выполнения с помощью методов, таких как Promise.then(), process.nextTick() (в Node.js) или MutationObserver. Примеры микрозадач – выполнение обработчиков промисов и мутации DOM.</p> <p>С другой стороны, <span>макрозадачи</span> – это задачи, которые должны быть выполнены <span>после</span> окончания текущего цикла событий и <span>перед</span> тем, как изменения будут отрендерены на экране. Это включает задачи, добавленные в очередь событий с помощью setTimeout, setInterval, requestAnimationFrame, а также обработку входных событий и сетевых запросов. Макрозадачи выполняются <span>после</span> того, как завершается обработка <span>></span> микрозадач в текущем цикле событий.</p> <p>Разница между микрозадачами и макрозадачами определяет порядок выполнения и позволяет управлять приоритетами различных задач в JavaScript. Микрозадачи имеют более высокий приоритет и выполняются до макрозадач, что позволяет быстрее обновлять интерфейс и предотвращает блокировку основного потока выполнения JavaScript. В приведенном ниже примере <span>setTimeout</span> является макрозадачей, а <span>Promise.then()</span> – микрозадачей. Поскольку микрозадачи имеют более высокий приоритет, <span>Promise.then()</span> выполняется перед <span>setTimeout</span>, и поэтому <span>promise</span> появляется в первую очередь:</p> <p><img class='question__img' src='img/32proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 33,
    question: "Что такое генераторы?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>Генераторы в JavaScript</span> представляют собой специальный тип функций, которые генерируют последовательность значений <span>по одному</span> за раз по мере необходимости, и позволяют приостанавливать и возобновлять свое выполнение (в отличие от обычных функций, которые выполняются до завершения). Генераторы хорошо работают с объектами и упрощают создание потоков данных.</p> <p>Чтобы объявить генератор, используют специальный синтаксис – функцию-генератор. Функция-генератор определяется с помощью символа * после ключевого слова <span>function</span>:</p> <p><img class='question__img' src='img/33proglibPart2.png' alt=''></p> <p>Генератор возвращает итератор, который можно использовать для контроля над выполнением функции. Основной метод итератора – next(). Когда вызывается next(), выполнение кода продолжается до ближайшего оператора yield. Когда достигнут yield, выполнение функции приостанавливается, и соответствующее значение возвращается во внешний код.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 34,
    question: "Какие существуют методы для сохранения данных в браузере?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Есть 3 основных метода хранения данных в браузере:</p> <ul> <li><span>LocalStorage</span> и <span>SessionStorage</span> используются для хранения пар <span>ключ-значение</span>. Данные, сохраненные в них, сохраняются после обновления страницы. При этом только LocalStorage может сохранять данные <span>после перезапуска</span> браузера. Оба хранилища могут использовать только строки в качестве ключей и значений, поэтому объекты необходимо преобразовать с помощью <span>JSON.stringify()</span>.</li> <li><span>Cookie</span> – небольшие строки данных, которые хранятся в браузере. Cookie обычно устанавливаются веб-сервером с использованием заголовка Set-Cookie. Браузер затем автоматически добавляет их почти ко всем запросам на тот же домен с использованием заголовка Cookie. Один экземпляр cookie может содержать до 4 кб данных. В зависимости от браузера, допускается более 20 cookie на сайт.</li> <li><span>IndexedDB</span> – встроенная база данных, более мощная, чем localStorage. Это NoSQL-хранилище данных в формате JSON внутри браузера, где доступны несколько типов ключей, а значения могут быть практически любым. IndexedDB поддерживает асинхронный доступ, транзакции для обеспечения согласованности данных и создание индексов для эффективного поиска. Позволяет хранить больше данных, чем localStorage, может быть связана с Service Workers и другими технологиями, которые обеспечивают функционирование PWA в оффлайне.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 35,
    question: "В чем заключается разница между sessionStorage и localStorage?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Сессионное хранилище <span>sessionStorage</span> и локальное хранилище <span>localStorage</span> позволяют сохранять данные в формате <span>ключ-значение</span> в браузере. Оба они используются для хранения данных на стороне клиента, но имеют некоторые отличия:</p> <ul> <li><span>Объем хранимых данных</span> – localStorage может хранить до 10 МБ данных, в то время как sessionStorage может хранить только до 5 МБ данных.</li> <li><span>Срок хранения данных</span> – в localStorage данные не удаляются, когда закрывается браузер или вкладка. И напротив, данные в sessionStorage удаляются, когда закрывается вкладка или окно браузера.</li> <li><span>Доступность данных</span> – из localStorage данные доступны в любом окне браузера, в то время как данные из sessionStorage доступны только из того же окна браузера, где они были сохранены.</li> </ul>  ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 36,
    question: "Что такое регулярные выражения?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Регулярные выражения (regex) – это паттерны, которые используются для поиска и замены текста в строках. В паттернах используются комбинации специальных символов (шаблоны) и флаги (модификаторы, которые определяют поведение поиска). Регулярные выражения часто используют в комбинации с этими методами:</p> <ul> <li><span>test()</span> – проверка на соответствие шаблону</li> <li><span>match()</span> – поиск соответствий</li> <li><span>replace()</span> – замена по шаблону</li> <li><span>search()</span> – поиск индекса</li> </ul> <p>Составлять регулярные выражения можно с помощью конструктора RegExp или литеральной нотации.</p> <p><a class='question__link' href='https://proglib.io/p/shpargalka-po-regulyarnym-vyrazheniyam-v-javascript-2022-07-17' target='_blank' rel='noopener noreferrer'>Шпаргалка по регулярным выражениям в JavaScript</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 37,
    question:
      "В чем заключается разница между WeakSet, WeakMap и обычными Set и Map?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p><span>WeakSet и WeakMap</span> – это специальные структуры данных в JavaScript, которые отличаются особенностью хранения ссылок на объекты.</p> <p>В обычных Set и Map хранятся <span><</span> ссылки на объекты. Это значит, что пока существует ссылка на объект в этих структурах, сборщик мусора не удалит этот объект из памяти, даже если больше нигде в коде нет ссылок на него.</p> <p>И напротив, в WeakSet и WeakMap хранятся <span>слабые</span> ссылки. Это означает, что если объект, на который есть ссылка в этих структурах, больше недоступен в коде (т.е. нигде больше нет сильных ссылок на него), то сборщик мусора может удалить этот объект из памяти, даже если в WeakSet или WeakMap все еще есть ссылка на него. Таким образом, использование слабых ссылок позволяет не держать в памяти ненужные больше объекты и экономить память.</p> <p>Кроме того, в WeakMap в качестве ключей могут использоваться только объекты, а не примитивные значения. А в WeakSet хранятся только объекты, без ключей.</p> <p>Подробнее о Set и Map смотри<a class='question__link' href='https://learn.javascript.ru/map-set' target='_blank' rel='noopener noreferrer'>здесь.</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 38,
    question:
      "Почему два объекта с одинаковыми полями возвращают false при сравнении?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>В JavaScript объекты сравниваются по ссылкам на область памяти, где они хранятся. Два разных объекта, даже если у них одинаковые поля и значения этих полей, располагаются в разных областях памяти. Например, у нас есть:</p> <p>const example1 = {fruit: 'яблоко'}; <br> const example2 = {fruit: 'яблоко'}; <br> console.log(example1 == example2); // false</p> <p>Хотя у этих двух объектов одно и то же поле fruit со значением 'яблоко', на самом деле это два абсолютно разных объекта, которые хранятся в разных ячейках памяти. Поэтому если мы сравним их, результат будет false. Для того чтобы два объекта считались равными, нужно, чтобы это был один и тот же объект, то есть чтобы обе переменные ссылались на одну и ту же область памяти.</p>  ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 39,
    question: "Как в JavaScript реализованы методы примитивных типов данных?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>JavaScript позволяет работать с примитивными типами данных – строками, числами, логическими значениями – как с объектами, поскольку у них тоже есть методы. Например, у строк есть методы <span>toUpperCase()</span> и <span>toLowerCase()</span>, у чисел есть методы <span>toFixed()</span> и <span>toPrecision()</span> и т.д.</p> <p>Эта возможность реализована благодаря специальным оберточным объектам для каждого примитивного типа данных. Эти объекты называются:</p> <ul> <li><span>String</span> – для строк</li> <li><span>Number</span> – для чисел</li> <li><span>Boolean</span> – для логических значений</li> <li><span>Symbol</span> – для символов</li> </ul> <p>Когда мы вызываем метод у примитивного значения, например 'test'.toUpperCase(), происходит следующее:</p> <ul> <li>Создается временный оберточный объект типа Stringсо значением 'test'.</li> <li>У этого объекта вызывается метод toUpperCase().</li> <li>Результат возвращается обратно в примитивное значение.</li> <li>Временный оберточный объект удаляется.</li> </ul> <p>Таким образом реализуется возможность использовать методы у примитивных типов данных. Благодаря этому механизму, примитивы в JavaScript ведут себя как объекты.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 40,
    question: "Как проверить, из какого класса был создан объект?",
    answer: {
      href: "https://proglib.io/p/voprosy-dlya-podgotovki-k-sobesedovaniyu-po-javascript-chast-2-2024-02-12",
      linkName: "proglib.io",
      answer1:
        "<p>Для этого в JavaScript используется оператор <span>instanceof</span>. Он позволяет проверить, из какого класса был создан объект, учитывая наследование.</p> <p>Например, есть базовый класс Animal и классы-наследники Dog и Cat:</p> <p><img class='question__img' src='img/40.1proglibPart2.png' alt=''></p> <p>Создадим объект класса Dog и проверим с помощью оператораinstanceof, является ли объект экземпляром указанного класса или классов-родителей:</p> <p><img class='question__img' src='img/40.2proglibPart2.png' alt=''></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

/* 10 вопросов с собеседований по JavaScript */
/* https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01 */
/* разметка сделана */
const questionsJSProglib10 = [
  {
    id: 1,
    question: "Объясните стрелочные функции",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p><span>Ответ:</span>Стрелочная функция – это краткий способ записи функциональных выражений. Стрелочные функции не являются конструкторами, не поддерживают ключевые слова this, arguments, super и new.target и записываются следующим образом:</p> <p>const hello = () => { 	console.log('good morning'); } hello();</p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "Объясните NaN и его роль",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Когда интервьюер просит дать определение термину, этот термин, как правило, является широко используемым. В этом случае, термин NaN, который означает «не число» – важная концепция, понимание которой, потребуется разработчикам на JavaScript при работе с числовыми значениями.</p> <p><span>Ответ:</span>Когда значение в операции не число, оно возвращает NaN. Это может произойти в нескольких случаях. Например, если операция возвращает неподходящий результат, потому что часть функции была нечисловой или результат имеет значение, не являющееся числовым.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "Что такое примитивные типы данных в JavaScript?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Такой вопрос обычно оценивает ваши теоретические знания JavaScript. При ответе на этот вопрос рассмотрите возможность краткого перечисления всех примитивных типов данных, доступных в JavaScript.</p> <p><span>Ответ:</span>Фундаментальный тип данных, который не может быть создан от других типов данных. Он ограничен представлением одного значения. Все примитивы неизменяемы (immutable), не являются объектом и не имеют методов. По определению, все примитивы – встроенные типы данных, и компилятор должен знать их. Но не все встроенные типы данных – примитивы. В JavaScript доступно семь примитивных типов данных: undefined, null, boolean, string, number, bigint, symbol. Все остальное в JavaScript является объектом.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "Как рассчитать числа Фибоначчи в JavaScript?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Создать последовательность чисел Фибоначчи – очень популярная задача для программистов. Попробуйте правильно ответить на него с помощью кода.</p> <p><span>Ответ:</span>Последовательность чисел Фибоначчи – это последовательность чисел, где каждое значение – это сумма двух предыдущих, начинается с 0 и 1. Первые пять значений это 0, 1, 1, 2, 3, 5, 8. Пример кода: запросим ввод у пользователя const number = parseInt(prompt('Enter the no. of terms: '));  let n1 = 0, n2 = 1, nextNumber; console.log('Fibonacci Sequence:');  for (let i = 1; i <= number; i++) { console.log(n1); nextNumber = n1 + n2; n1 = n2; n2 = nextNumber; }</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Как динамически добавлять и удалять свойства в JavaScript?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p><span>>Ответ:</span>Вы можете добавить свойство к объекту используя, object.property_name = value, и удалить свойство, используя delete. Пример кода: delete person.age;</p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Объясните различие между Object.freeze() и const",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p><span>Ответ:</span> const и Object.freeze – две разные фичи JavaScript. const применяется только для неизменяемой ссылки на ячейку памяти со значением, что означает невозможность задать новое значение для переменной. Object.freeze работает со значениями объектов. Делает объект неизменяемым, то есть изменить его свойства невозможно.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Объясните, что такое файлы cookie в JavaScript",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>С помощью этого вопроса интервьюер оценивает ваши базовые знания в веб-разработке.</p> <p><span>Ответ:</span>  Cookies – это небольшие текстовые файлы, которые хранятся на компьютере и создаются, когда пользователь заходит на веб-сайты. Например, это могут быть сведения о пользователе или информация о содержимом корзины покупок из прошлых посещений.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Для чего используются операторы break и continue в JavaScript?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Эти два термина относятся к циклам. Попробуйте объяснить, как операторы break и continue влияют на цикл.</p> <p><span>Ответ:</span>  Оператор break выходит из запущенного цикла в то время как, оператор continue продолжает работу после прерывания всего одной итерации. Оба оператора позволяют написать сложную циклическую функцию с различными результатами и требуемыми действиями на основе заданного результата функции</p>.",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Зачем оборачивать содержимое исходного JS-файла в блок функции?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Ответ на этот вопрос может показать ваши знания вспомогательных процессов, которые, скорее всего, специфичны для библиотеки.</p> <p><span>Ответ:</span> Этот метод заключает в себя содержимое файла, создавая приватное пространство имен. Такая реализация позволяет избежать конфликта между объектами JavaScript и библиотеками, в которых они размещены.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question:
      "Каковы преимущества и недостатки монолитной и микросервисной архитектуры?",
    answer: {
      href: "https://proglib.io/p/10-voprosov-s-sobesedovaniy-po-javascript-2022-02-01",
      linkName: "proglib.io",
      answer1:
        "<p>Интервьюер, вероятно, хочет увидеть, понимаете ли вы различия между ними и достаточно ли осведомлены о них, чтобы определить наиболее практичный подход в любой конкретной ситуации. </p> <p><span>Ответ:</span>Монолитные архитектуры обычно реализуются как приложение в виде единого компонента, что упрощает добавление задач, связанных со сквозной функциональностью (англ. сross-cutting concern), таких как: ограничение запросов, ведение журнала и различные функции безопасности. То есть к сквозной относится «вспомогательная» функциональность модуля, не относящаяся напрямую к выполняемой задаче, но необходимая. Поначалу такая архитектура может показаться более практичной, но по мере развития приложения становится все труднее поддерживать код или масштабировать его.</p> <p>Стоит принимать во внимание, что микросервисы будут иметь широкий круг задач, связанных со сквозной функциональностью, которые не предполагались на этапе проектирования. В долгосрочной перспективе они, как правило, предпочтительнее из-за их автономной организации, что позволяет легко реструктурировать их по мере расширения или изменения их назначения.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

/* 30 вопросов на собеседовании фронтенд разработчика */
/* https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika */
/* разметка сделана */
const questionsJSTproger30 = [
  {
    id: 1,
    question: "Разница между let, var и const",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>let, var и const — это ключевые слова, используемые в JavaScript для объявления переменных.</p> <p>var долгое время был основным способом объявления переменных в JavaScript до появления let и const. var имеет область видимости функции и может быть изменен в любом месте в этой функции.</p> <p>let и const были добавлены в стандарт ECMAScript 6 (ES6) и имеют блочную область видимости. let может быть изменен, но const не может</p> <p>Используйте let, если вы собираетесь изменять значение переменной, и const, если не собираетесь. Используйте var, если вам нужно поддерживать совместимость со старыми браузерами или если вы хотите использовать его особенности, такие как функциональная область видимости.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "Разница между cookie, sessionStorage и localStorage",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Вот он, родной и горячо любимый HTML.</p> <p>cookie, sessionStorage и localStorage — это технологии для хранения данных на стороне клиента в браузере. Однако, у них есть различия в использовании и хранении данных.</p> <p>cookie — небольшой фрагмент данных, который отправляется сервером в браузер, а затем сохраняется в браузере клиента. Cookie могут храниться в течение определённого периода времени, определяемого сервером. Они используются для сохранения пользовательских настроек, данных авторизации и другой информации о пользователях.</p> <p>sessionStorage — объект, который позволяет сохранять данные в браузере на время сессии, т.е. пока вкладка браузера открыта. Данные сохраняются в виде пары ключ-значение, и они могут быть использованы для сохранения состояния приложения или другой информации, которая должна быть доступна только в течение сессии.</p> <p>localStorage — объект, который позволяет сохранять данные в браузере на неопределенный период времени, т.е. данные будут доступны даже после закрытия браузера и перезагрузки компьютера. Данные также сохраняются в виде пары ключ-значение и могут быть использованы для сохранения состояния приложения или другой информации, которая должна быть доступна в любое время.</p> <p>В целом, разница между cookie, sessionStorage и localStorage заключается в их жизненном цикле и времени жизни, а также в том, как они могут быть использованы в приложениях.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question:
      "Какая технология наиболее популярна сейчас и точно будет популярна ещё несколько лет?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Резкий скачок от чисто технических вопросов на собеседовании Junior frontend к чисто философским, не так ли? Но сегодня это нормальная практика, и ей не стоит удивляться.</p> <p>Сразу хочется подчеркнуть, что здесь нет единого правильного варианта ответа, ведь фронт-енд в последние годы стал очень многогранен, обзавёлся кучей прогрессивных библиотек и фреймворков. Поэтому давайте поразмышляем в несколько творческом ключе.</p> <p>Сейчас в веб-разработке наиболее популярным языком является JavaScript и его фреймворки, такие как React, Angular и Vue.js. JavaScript используется для создания интерактивных пользовательских интерфейсов, а также для создания бэкенд-серверов с помощью Node.js.</p> <p>Не стоит забывать и о набирающих популярность технологиях, которые связаны с искусственным интеллектом, машинным обучением и анализом данных. Скорее всего, они также будут иметь значительное влияние на веб-разработку в будущем. В частности, библиотеки и фреймворки для визуализации данных, такие как D3.js и Chart.js, станут очень популярны в создении интерактивных графиков и диаграмм на веб-сайтах.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question:
      "Напишите простую функцию, чтобы проверить, является ли число целым",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Здесь всё просто:</p> <p>function isInteger(num) {</p> <p>return num % 1 === 0;}</p> <p>Эта функция принимает число в качестве аргумента и возвращает true, если число является целым, и false, если число имеет дробную часть.</p> <p>onsole.log(isInteger(4)); // true console.log(isInteger(4.2)); // false console.log(isInteger(-3)); // true</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Что такое прогрессивная отрисовка?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Да, некоторые вопросы для фронтенд разработчика могут быть даже такими.</p> <p>Прогрессивная отрисовка — это метод веб-разработки, который позволяет поэтапно отображать содержимое веб-страницы по мере его загрузки. Сначала отображается минимальное количество информации, а затем дополнительные элементы и детали добавляются по мере загрузки страницы.</p> <p>Этот подход особенно полезен для улучшения пользовательского опыта и снижения времени загрузки страницы. Пользователи могут начать взаимодействовать с сайтом намного быстрее, чем если бы они должны были ждать, пока вся страница будет загружена полностью.</p> <p>Кроме того, прогрессивная отрисовка также может быть полезна для оптимизации производительности, поскольку она позволяет снизить объем передаваемых данных и ускорить время отклика сервера.</p> <p>Примеры технологий, которые позволяют использовать прогрессивную отрисовку, включают в себя постраничную подгрузку контента, ленивую загрузку изображений и использование CSS-анимации для плавного отображения элементов страницы.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question:
      "На что стоит обратить внимание при разработке мультиязычных сайтов?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>При разработке мультиязычных сайтов необходимо обратить внимание на следующие аспекты:</p> <ol> <li>Выбор подходящей системы управления контентом (CMS). Некоторые CMS, такие как WordPress и Drupal, предоставляют встроенную поддержку мультиязычности, что может значительно упростить разработку и управление мультиязычными сайтами.</li> <li>Кодирование текста и использование правильных языковых символов. Кодировка должна соответствовать требованиям языков, на которых будет отображаться сайт. Например, для языков, использующих кириллицу, должна быть выбрана кодировка UTF-8.</li> <li>Организация контента на сайте. Необходимо разработать систему, которая позволит организовать контент на сайте таким образом, чтобы пользователи могли легко найти информацию на нужном им языке. Для этого можно использовать разделение контента на языковые версии или использовать переключатели языков.</li> <li>Локализация. При переводе текста на другой язык необходимо учитывать культурные особенности языка и местные нормы и стандарты. Кроме того, может потребоваться локализация форматов дат, валют и других данных, которые зависят от конкретного региона.</li> <li>Тестирование и отладка. Необходимо тщательно протестировать все языковые версии сайта, чтобы убедиться, что контент отображается корректно, а функциональность работает правильно на всех языках.</li> <li>SEO-оптимизация для каждого языка. Для каждой языковой версии сайта необходимо провести SEO-анализ и оптимизировать контент, мета-теги и другие аспекты для местных поисковых систем и языковых запросов пользователей.Например, таким бы было оформление sitemap.xml, будь у Tproger английская версия</li> </ol> <p>Подробнее о мультиязычной настройке Sitemap можно почитать в <a class='question__link' href='https://developers.google.com/search/docs/specialty/international/localized-versions?hl=ru#sitemap' target='_blank' rel='noopener noreferrer'>документации Google.</a> </p> <p>Учитывая эти аспекты, можно разработать качественный мультиязычный сайт, который будет удобен и понятен для пользователей на разных языках</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Написать код для получения текущего URL",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>В JavaScript можно получить текущий URL страницы, используя свойство window.location.href:</p> <p>const currentUrl = window.location.href; // выведет текущий URL в консоль</p> <p>console.log(currentUrl);</p> <p>Подобные вопросы на собеседовании frontend разработчика звучат нечасто, но всё же ответ должен быть полным.</p> <p>Итак, это свойство возвращает текущий URL, включая протокол, имя хоста, порт (если он есть), путь и параметры запроса. Если необходимо получить только определенную часть URL (например, только путь), можно использовать другие свойства объекта window.location, такие как pathname или search.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question:
      "Разница между &lt;script&gt;, &lt;script async&gt; и &lt;script defer&gt;",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Тег <script> используется для загрузки и выполнения JavaScript-кода на веб-странице. Тег <script> может иметь атрибуты async и defer, которые позволяют задать способ загрузки скрипта.</p> <p><script>  будет загружаться и выполняться синхронно, т.е. парсер HTML-документа остановится на этом теге, выполнит скрипт, и только после этого продолжит загрузку страницы.</p> <p></p> <p></p> <p><script async> будет загружаться асинхронно, т.е. парсер HTML-документа продолжит загрузку страницы без ожидания загрузки и выполнения скрипта. Как только скрипт будет загружен, он начнет выполняться, даже если страница еще не полностью загружена.</p> <p><script defer> также будет загружаться асинхронно, но его выполнение будет отложено до того момента, когда страница будет полностью загружена.</p> <p>Примеры:</p> <ul> <li><script src='script.js'></script></li> <li><script async src='script.js'></script></li> <li><script defer src='script.js'></script></li> </ul> <p>Важно отметить, что использование атрибутов async и defer может повлиять на порядок выполнения скриптов на странице, поэтому необходимо тщательно планировать их использование. Подобные развёрнутые ответы на вопросы на собеседовании фронтенд разработчика дадут вам значительное преимущество</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Что такое REST и RESTful API?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>REST (Representational State Transfer) — это архитектурный стиль, используемый при проектировании распределенных систем. Он был описан в диссертации Роя Филдинга в 2000 году и является основой для создания RESTful API.</p> <p>RESTful API — это веб-сервис, который использует протокол HTTP для обмена данными. Он предоставляет возможность получать, создавать, обновлять и удалять данные на удаленном сервере, используя стандартные HTTP-методы (GET, POST, PUT, DELETE и т. д.).</p> <p>RESTful API использует ресурсы (например, товары, пользователи, заказы) и URI (Uniform Resource Identifier) для доступа к этим ресурсам. Клиент отправляет запросы на сервер, указывая URI и метод HTTP, а сервер возвращает ответ, который может содержать данные в различных форматах (например, JSON или XML).</p> <p>Принципы RESTful API:</p> <ol> <li>Клиент-серверная архитектура: сервер и клиент независимы друг от друга, что позволяет развивать их независимо.</li> <li>Отсутствие состояния (stateless): каждый запрос клиента должен содержать всю необходимую информацию для его обработки, без сохранения состояния на сервере.</li> <li>Кэширование: клиенты могут кэшировать ответы сервера, чтобы уменьшить количество запросов.</li> <li>Единообразие интерфейса: единообразный интерфейс между клиентом и сервером упрощает взаимодействие и увеличивает его надежность.</li> <li>Слои: клиент не должен знать о слоях на сервере, которые обрабатывают запросы.</li> </ol> <p>RESTful API является широко используемым в веб-разработке и предоставляет удобный и гибкий способ обмена данными между сервером и клиентом.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Разница между «сбросом» и «нормализацией» CSS",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Заметили, что вопросы Junior frontend разработчику часто включают в себя какие-то сравнения? Это неспроста. Интервьюеры специально «гоняют» по отличиям, чтобы одним махом понять вашу осведомлённость во всех сравниваемых элементах.</p> <p>Ответить на этот фронтенд вопрос несложно.</p> <p>Сброс CSS и нормализация CSS — это два разных подхода к обнулению стилей веб-страницы.</p> <p>Сброс CSS — это процесс обнуления стилей, чтобы убрать браузерные стили по умолчанию, которые могут отличаться от одного браузера к другому. Цель сброса CSS — создать «чистую» страницу, на которой все элементы имеют одинаковый вид в разных браузерах. Пример кода:</p> <p>/* сброс CSS */</p> <p>{ margin: 0; padding: 0; box-sizing: border-box; }</p> <p>Нормализация CSS — это процесс создания единообразных стилей для разных элементов, чтобы веб-страница выглядела одинаково во всех браузерах. В отличие от сброса CSS, нормализация CSS сохраняет некоторые стили по умолчанию браузера, но при этом пытается сделать их единообразными. Пример:</p> <p>/* нормализация CSS */</p> <p>body { font-size: 1.6rem; line-height: 1.5; font-family: Arial, sans-serif; }</p> <p>Оба подхода могут использоваться в зависимости от нужд проекта. Если вы хотите создать полностью уникальный дизайн, то возможно вам нужен сброс CSS. Если же вы хотите сохранить некоторые стили браузера, но при этом сделать веб-страницу более единообразной, то нормализация CSS может быть более подходящим вариантом.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Что такое «трёхстороннее рукопожатие»?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Медленно но уверенно вопросы для frontend разработчика перетекли в сферу безопасности./p> <p>Трехстороннее рукопожатие (Triple Handshake) — это проблема безопасности в компьютерных сетях, которая возникает при использовании SSL/TLS-соединений.</p> <p>В процессе установки безопасного соединения SSL/TLS между клиентом и сервером происходит обмен сообщениями, который состоит из трех шагов (трехстороннее рукопожатие):</p> <ol> <li>Клиент отправляет серверу сообщение SYN с произвольным начальным номером (seq).</li> <li>Сервер отправляет клиенту сообщение SYN-ACK, подтверждающее получение сообщения SYN и содержащее свой собственный произвольный начальный номер (seq) и номер последовательности подтверждения (ack), который равен начальному номеру клиента +1.</li> <li>Клиент отправляет серверу сообщение ACK с номером подтверждения, который равен начальному номеру сервера +1.</li> </ol> <p>Проблема Triple Handshake возникает, когда злоумышленник нарушает правильный порядок шагов рукопожатия, вставляя свой сервер между клиентом и настоящим сервером. В этом случае злоумышленник может получить доступ к конфиденциальной информации, передаваемой между клиентом и сервером.</p> <p>Чтобы избежать проблемы Triple Handshake, необходимо использовать проверенные и безопасные протоколы SSL/TLS и устанавливать соединение только с доверенными серверами.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "Что такое NaN?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Это специальное значение в JavaScript, которое означает «не число» (Not-a-Number).</p> <p>Возможные причины, по которым значение становится NaN:</p> <ul> <li>Попытка выполнить математическую операцию с нечисловым значением.</li> <li>Попытка выполнить математическую операцию, результат которой не может быть представлен числом, например деление нуля на ноль или вычисление квадратного корня из отрицательного числа.</li> <li>Преобразование строки в число, если строка не является валидным числом.</li></ul> <p>Значение NaN имеет интересное свойство: оно не равно ни одному другому значению, включая само себя. Поэтому существует специальная функция isNaN(), которая позволяет проверить, является ли значение NaN: <span>let result = isNaN(NaN); // result будет равен true, let result3 = isNaN(10); // result3 будет равен false, потому что 10 - это число</span></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Как реализовать отложенную загрузку изображений?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Да, такие вопросы фронтенд разработчик должен щёлкать, как семечки. </p> <p>Отложенная загрузка изображений — это способность страницы загружать изображения только тогда, когда они понадобятся пользователю. Это может ускорить время загрузки страницы и уменьшить использование данных. Есть несколько способов реализации отложенной загрузки изображений.</p> <p>Lazy Loading — техника, которая позволяет отложить загрузку изображений, находящихся за пределами видимой области. Для этого можно использовать библиотеки, такие как Lazysizes или Intersection Observer API.</p> <p>Атрибуты data- — Вы можете использовать атрибут data- вместе с атрибутом src, чтобы отложить загрузку изображения: <span><img data-src='path-to-image.jpg' alt='Alt text'></span> </p> <p>Затем вы можете использовать JavaScript, чтобы загрузить изображение, когда оно станет видимым: <span>const img = document.querySelector('img'); img.setAttribute('src', img.getAttribute('data-src'));</span></p> <p>Использование CSS для изменения размера изображения, уменьшения его качества или изменения его формата. Например, вы можете использовать свойство “background-image” для загрузки изображения как фон элемента: <span>.element { background-image: url(path-to-image.pg); }</span></p> <p>Это не полный список способов реализации отложенной загрузки изображений, и выбор конкретных методов зависит от требований проекта и целевой аудитории.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "Что такое Event loop и как он работает?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>это механизм в JavaScript, который позволяет выполнить асинхронный код и обрабатывать события, такие как клики мыши, нажатия клавиш и таймеры.</p> <p>Event loop работает внутри JavaScript движка и состоит из двух основных фаз: фаза синхронизации и фаза выполнения задач. В фазе синхронизации обрабатываются синхронные операции, такие как выполнение кода и обработка событий, которые были помещены в очередь в прошлый цикл. В фазе выполнения задач обрабатываются асинхронные операции, такие как колбэки таймеров и событий.</p> <p>Когда JavaScript выполняет код, все синхронные операции помещаются в очередь. Когда очередь становится пустой, Event loop проверяет, есть ли в очереди асинхронные операции. Если есть, они выполняются в порядке их добавления в очередь.</p> <p>Например, если мы вызываем setTimeout с задержкой в 1 секунду, функция setTimeout помещает колбэк функцию в очередь и устанавливает таймер на 1 секунду. Когда таймер сработает, колбэк функция будет добавлена в очередь, и Event loop выполнит ее.</p> <p>Важно понимать, что фаза выполнения задач может быть перервана фазой синхронизации. Например, если мы запускаем бесконечный цикл, который занимает все ресурсы процессора, JavaScript не сможет выполнить другие задачи, пока цикл не закончится.</p> <p>Event loop является важным концептом в асинхронном программировании на JavaScript, поэтому важно понимать, как он работает, чтобы писать эффективный и предсказуемый асинхронный код.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "В чём разница между .call и .apply?",
    answer: {
      href: "https://tproger.ru/articles/20-voprosov-na-sobesedovanii-frontend-razrabotchika1",
      linkName: "tproger.ru",
      answer1:
        "<p>Методы .call() и .apply() используются для вызова функции с заданным значением this, а также для передачи аргументов в функцию. Основная разница между ними заключается в способе передачи аргументов.</p> <p>Метод .call() принимает список аргументов, переданных в функцию через запятую. В то же время, метод .apply() принимает массив аргументов, переданных в функцию.</p> <p>Вот пример использования методов .call() и .apply():</p> <p>function greet(name, age) {console.log(`Hello, my name is ${name} and I am ${age} years old.`); }</p> <p>greet.call(null, 'John', 30);</p> <p>greet.apply(null, ['Jane', 25]);</p> <p>В обоих случаях мы вызываем функцию greet() с this равным null. В первом случае мы передаем два аргумента в функцию через запятую, а во втором случае мы передаем массив из двух аргументов в функцию.</p> <p>Понравился такой формат? Держите ещё 15 интересных вопросов к собеседованию фронтенд. Проверьте себя: пишите свои ответы в комментариях.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

/* Вопросы и ответы для собеседования на позицию frontend-разработчик. Часть 1 */
/* https://habr.com/ru/articles/784548/ */
/* разметка сделана */
const questionsJSHabrPart1 = [
  {
    id: 1,
    question: "Что такое цикл событий (event loop) и как он работает?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Цикл событий (event loop) - это механизм, используемый в JavaScript и других языках программирования для обработки событий и выполнения асинхронного кода. Он позволяет программе эффективно обрабатывать события, такие как пользовательские действия, таймеры, сетевые запросы и другие асинхронные операции.</p> <p>Работа цикла событий в JavaScript обычно выглядит следующим образом:</p> <ol> <li>Ожидание событий: Цикл событий начинает свою работу, ожидая возникновения событий. Это могут быть пользовательские действия (например, щелчки мыши или нажатия клавиш), таймеры, сетевые запросы или другие асинхронные операции.</li> <li>Обработка событий: Когда событие происходит, оно помещается в очередь событий (event queue). Цикл событий извлекает событие из очереди и передает его на обработку.</li> <li>Выполнение обработчиков событий: Цикл событий вызывает соответствующий обработчик события, который содержит код, который должен быть выполнен в ответ на событие. Обработчик выполняется синхронно, то есть блокирует выполнение других событий до завершения.</li> <li>Обработка асинхронного кода: Если в обработчике события есть асинхронный код, такой как таймеры или сетевые запросы, он не блокирует выполнение других событий. Вместо этого асинхронный код помещается в очередь задач (task queue) для выполнения в будущем.</li> <li>Возврат к ожиданию событий: После выполнения всех обработчиков событий и обработки асинхронного кода, цикл событий возвращается к ожиданию новых событий. Процесс повторяется, пока не будет завершена работа программы.</li> </ol> <p>Цикл событий позволяет JavaScript выполнять асинхронный код без блокировки основного потока выполнения. Это позволяет создавать отзывчивые веб-приложения, которые могут обрабатывать пользовательские действия и одновременно выполнять другие задачи, такие как загрузка данных или анимации.</p> <p>Еще можно почитать <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Event_loop' target='_blank' rel='noopener noreferrer'>здесь</a></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "Какие типы данных есть в JS?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Часто кандидаты ошибаются, когда отвечают на этот вопрос, почему так происходит не понятно</p> <p>Всего в JS 8 типов данных:</p> <ul> <li>Число (number)</li> <li>Строка (string)</li> <li>Булевый (логический) тип (boolean)</li> <li>BigInt</li> <li>Symbol</li>  <li>null</li>  <li>undefiend</li> <li>Object</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question:
      "Что такое NaN? Какого типа это значение? Как можно узнать, равно ли значение переменной NaN?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>NaN расшифровывается как 'Not A Number', это 'false' (ложное) значение. Будьте аккуратны, выражение typeof NaN возвращает тип Number. Чтобы проверить значение переменной на соответствие NaN можно, воспользовавшись встроенным методом isNaN() или используя оператор тройного равенства ===.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "В чем разница между let, const и var?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Начнем с var:</p> <ul> <li>Переменные, объявленные с помощью var, имеют функциональную область видимости или область видимости внутри целого файла.</li> <li>Переменные var могут быть переопределены и переобъявлены в той же области видимости.</li> <li>Переменные var поднимаются (hoisted) в начало своей области видимости, что означает, что их можно использовать до их фактического объявления.</li> </ul> <p>let:</p> <ul> <li>Переменные, объявленные с помощью let, имеют блочную область видимости, ограниченную фигурными скобками {}.</li> <li>Переменные let не могут быть переобъявлены в той же области видимости, но могут быть переопределены.</li> <li>Переменные let не поднимаются (не hoisted) и не могут быть использованы до их объявления.</li> </ul> <p>const:</p> <ul> <li>Переменные, объявленные с помощью const, также имеют блочную область видимости.</li> <li>Переменные const должны быть инициализированы при объявлении и их значение не может быть изменено после этого.</li> <li>Переменные const не могут быть переобъявлены или переопределены.</li> <li>const также создает неизменяемую ссылку на объект, поэтому значения внутри объекта могут быть изменены, но сама ссылка остается неизменной.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question:
      "Что такое this? Отличие this в function declaration и стрелочных функциях",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>this - это специальное ключевое слово в JavaScript, которое ссылается на объект, в контексте которого выполняется текущий код. Значение this зависит от контекста вызова функции и может быть разным в различных ситуациях.</p> <p>Функции (function declaration):</p> <ul> <li>В функциях объявления значение this определяется во время выполнения функции, в зависимости от способа вызова функции.</li> <li>Если функция вызывается как метод объекта, то this ссылается на сам объект, на котором вызывается метод.</li> <li>Если функция вызывается как обычная функция, то this ссылается на глобальный объект (в браузере это объект window).</li> </ul> <p>Стрелочные функции (arrow functions):</p> <ul> <li>В стрелочных функциях значение this определяется лексически, оно берется из окружающего контекста, в котором функция была определена.</li> <li>Стрелочные функции не имеют своего собственного this, поэтому они не создают новый контекст this и не зависят от способа вызова.</li> <li>Вместо этого, this в стрелочных функциях ссылается на this окружающего контекста.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "С помощью чего в JS реализуются наследование?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>В JavaScript наследование реализуется с помощью прототипов. Прототипное наследование - это механизм, который позволяет объектам наследовать свойства и методы других объектов. Еще появился новый в ECMAScript 2015 с помощью ключевого слова class.</p> <p>Каждый объект в JavaScript имеет внутреннюю ссылку на прототип (prototype), которая указывает на другой объект. </p> <p>Существует несколько способов реализации наследования в JavaScript, рассмотрим их все.</p> <p>Прототипное наследование с использованием prototype:</p> <ul> <li>Создается конструктор (функция-класс), у которого есть свойство prototype.</li> <li>Создаются новые объекты с помощью этого конструктора с помощью ключевого слова new.</li> <li>Прототип нового объекта устанавливается равным прототипу конструктора.</li> </ul> <p>Наследование с использованием class (введено в ECMAScript 2015):</p> <ul> <li>Используется ключевое слово class для определения класса.</li> <li>Используется ключевое слово extends для указания родительского класса.</li> <li>Методы родительского класса могут быть переопределены или расширены в дочернем классе с помощью ключевого слова super.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "Что такое IIFE (Immediately Invoked Function Expression)?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>IIFE (Immediately Invoked Function Expression) - это выражение функции, которое вызывается немедленно после его определения. Оно позволяет создавать локальную область видимости для переменных и функций, чтобы избежать конфликтов имен и сохранить приватность данных.</p> <p>IIFE обычно используется для создания модулей, эмуляции блока кода с областью видимости или для выполнения некоторых инициализаций при загрузке страницы.</p> <p>Пример IIFE: <span>(function() {   // Код, который будет выполнен немедленно  var x = 5; console.log(x); // Выводит 5 })();</span> </p> <p>В приведенном примере, функция обернута в круглые скобки (function() { ... }), чтобы превратить ее в выражение. Затем, после закрывающей скобки, добавляются еще одни круглые скобки () для вызова функции немедленно.</p> <p>IIFE может принимать аргументы, например: <span>(function(name) { console.log('Hello, ' + name); })('John'); // Выводит 'Hello, John'</span></p> <p>IIFE также может возвращать значение, которое может быть присвоено переменной: </p> <p><span>var result = (function() { return 5 + 3; })(); console.log(result); // Выводит 8</span></p> <p>Использование IIFE помогает изолировать код и предотвращает его влияние на глобальную область видимости, что способствует более безопасному и организованному коду.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "В чем разница между == и ===?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>В JavaScript операторы сравнения == (двойное равенство) и === (тройное равенство) используются для сравнения значений. Они имеют следующие различия:</p> <p>== (двойное равенство):</p> <ul> <li>Оператор == выполняет нестрогое сравнение, сравнивая значения с приведением типов, если это необходимо.</li> <li>Если типы операндов различаются, JavaScript пытается привести их к одному типу перед сравнением.</li> <li>Например, при сравнении числа и строки, строка будет преобразована в число перед сравнением.</li> </ul> <p>=== (тройное равенство):</p> <ul> <li>Оператор === выполняет строгое сравнение, сравнивая значения без приведения типов.</li> <li>Он сравнивает значения и типы операндов, и возвращает true только если они идентичны.</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Что такое замыкание в JavaScript?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>В JavaScript замыкание (closure) - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Замыкание позволяет функции сохранять доступ к переменным из своего внешнего лексического окружения, даже после того, как это окружение было удалено.</p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Что такое Promise, и какие бывают состояния",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Promise - это объект в JavaScript, который представляет результат асинхронной операции. Промис позволяет обрабатывать результат операции, когда он станет доступным, вместо того, чтобы блокировать выполнение кода и ожидать завершения операции.</p> <p>Промис может находиться в одном из трех состояний:</p> <p><span>Pending:</span> Исходное состояние промиса. Он находится в ожидании выполнения или отклонения операции.</p> <p><span>Fulfilled:</span> Промис переходит в это состояние, когда операция успешно завершается. В этом случае промис возвращает результат операции.</p> <p><span>Rejected:</span> Промис переходит в это состояние, когда операция завершается с ошибкой. В этом случае промис возвращает причину ошибки.</p> <p></p> <p></p> <p></p> ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "В чем разница и схожесть между null и undefined?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Null и undefined - это два различных значения в JavaScript, которые указывают на отсутствие значения.</p> <p>Различия:</p> <ul> <li>null - это явное значение, которое указывает на отсутствие или намеренное присвоение пустого значения. undefined - это значение, которое указывает на отсутствие присвоенного значения</li> <li>null - это объектный тип данных, который представляет отсутствие объекта. undefined - это примитивный тип данных.</li> <li>null может быть присвоен явно, чтобы указать на отсутствие значения. undefined - это значение, которое присваивается переменной по умолчанию, когда она объявлена, но не инициализирована.</li> </ul> <p>Сходства:</p> <ul> <li>Осутствие значения: Оба значения, null и undefined, указывают на отсутствие значения.</li> <li>Истинность: Оба значения рассматриваются как ложные (falsy) в логическом контексте. Это означает, что они преобразуются в false, когда используются в условных выражениях.</li> <li>Присваивание: Оба значения могут быть присвоены переменным или свойствам объекта.</li> <li>Тип данных: Оба значения являются уникальными значениями и не имеют своих собственных типов данных.</li> </ul> <p>В целом, null используется, когда явно указывается отсутствие значения, в то время как undefined указывает на отсутствие присвоенного значения.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question:
      "Почему результатом сравнения двух похожих объектов является false?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Результатом сравнения двух похожих объектов в JavaScript может быть false, потому что сравнение объектов происходит по ссылке, а не по содержимому.</p> <p>Когда мы сравниваем два объекта, JavaScript проверяет, указывают ли оба операнда на один и тот же объект в памяти. Если это так, то результатом будет true. Однако, если операнды указывают на разные объекты, даже если они имеют одинаковую структуру и значения свойств, результатом будет false.</p> <p>Пример: <span>const obj1 = { name: 'John', age: 25 }; const obj2 = { name: 'John', age: 25 }; console.log(obj1 === obj2); // Вывод: false</span></p> <p>В этом примере obj1 и obj2 содержат одинаковые свойства и значения, но они являются разными объектами в памяти. Поэтому результатом сравнения obj1 === obj2 будет false.</p> <p>Если вам нужно сравнить содержимое двух объектов, вам придется реализовать собственную логику сравнения, перебирая свойства объектов и сравнивая их значения.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "Для чего используется директива «use strict»?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Директива 'use strict' используется в JavaScript для включения строгого режима выполнения кода. Когда эта директива указана в начале скрипта или функции, JavaScript выполняет код в строгом режиме, что означает, что некоторые неявные или устаревшие функции и конструкции языка будут запрещены или изменены, а некоторые ошибки будут вызывать исключения.</p> <p>В основном используется для:</p> <ul> <li>Предотвращение ошибок</li> <li>Устранение неявных глобальных переменных</li> <li>Запрет использования некоторых устаревших функций и конструкций</li> <li>Улучшение безопасности</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "В чем разница между методами call, apply, bind?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Методы call, apply и bind являются частью языка JavaScript и используются для управления контекстом выполнения функций. Вот их основные различия:</p> <p><span>call:</span> Этот метод вызывает функцию с указанным контекстом и аргументами, переданными в виде отдельных аргументов. Синтаксис метода call выглядит следующим образом: function.call(context, arg1, arg2, ...). При использовании call аргументы передаются в виде списка, разделенного запятыми.</p> <p><span>apply:</span> Этот метод вызывает функцию с указанным контекстом и аргументами, переданными в виде массива. Синтаксис метода apply выглядит следующим образом: function.apply(context, [arg1, arg2, ...]). При использовании apply аргументы передаются в виде массива.</p> <p><span>bind:</span> Этот метод создает новую функцию, привязанную к указанному контексту. Он не вызывает функцию немедленно, а возвращает новую функцию, которую можно вызвать позже. Синтаксис метода bind выглядит следующим образом: function.bind(context). При использовании bind контекст функции фиксируется, и при вызове новой функции этот контекст будет сохраняться.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "Что такое функции высшего порядка?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Функции высшего порядка - это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. В JavaScript функции высшего порядка являются мощным инструментом, позволяющим создавать более гибкий и модульный код. Вот несколько примеров функций высшего порядка:</p> <p>Функция обратного вызова (Callback): Функция, которая передается в качестве аргумента в другую функцию и вызывается внутри нее. Это позволяет передавать логику выполнения внутрь другой функции.</p> <p>Пример: <span>function add(a, b) { return a + b; }</span></p> <p>Функция обертка (Wrapper): Функция, которая принимает другую функцию и возвращает новую функцию, добавляя дополнительную логику или изменяя поведение оригинальной функции.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "Как создать объект, не имеющий прототипа?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>В JavaScript объекты обычно наследуют свойства и методы от своих прототипов. Однако, существует несколько способов создания объекта без прототипа:</p> <p>Использование Object.create(null): Метод Object.create(null) создает новый объект с указанным прототипом null, что означает, что объект не будет наследовать свойства и методы от какого-либо прототипа.</p> <p>Пример: <span>const obj = Object.create(null); console.log(obj.toString); // Вывод: undefined</span></p> <p>Использование литерала объекта и null в качестве прототипа: Можно создать объект, используя литерал объекта и установив его прототип в null.</p> <p>Пример: <span>const obj = Object.setPrototypeOf({}, null); console.log(obj.toString); // Вывод: undefined</span></p> <p>Использование функции-конструктора без прототипа: Можно создать функцию-конструктор, которая не имеет прототипа, и создать объект с помощью этой функции.</p> <p>Пример: <span>function NoPrototype() { // Пустая функция-конструктор без прототипа } const obj = new NoPrototype(); console.log(obj.toString); // Вывод: undefined</span></p> <p>Обратите внимание, что объекты без прототипа могут быть полезны в определенных случаях, но они также могут ограничивать функциональность и использование стандартных методов и свойств. Поэтому рекомендуется использовать объекты без прототипа с осторожностью и только в случаях, когда это действительно необходимо.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "Что такое async/await?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>async/await - это синтаксический сахар в языке программирования, который позволяет писать асинхронный код в более понятном и линейном стиле. Он используется в языках, поддерживающих асинхронное программирование, таких как JavaScript, C#, Python и других.</p> <p>Преимущества использования async/await включают более простой и понятный синтаксис, отсутствие необходимости в явном использовании колбэков или цепочек промисов, а также возможность использования блоков try/catch для обработки ошибок.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "В чем разница между spread-оператором и rest-оператором?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Spread-оператор и rest-оператор - это два разных оператора, которые используются в JavaScript для работы с массивами и объектами.</p> <p>Spread-оператор (...):</p> <ul> <li>Распространяет элементы массива или свойства объекта.</li> <li>Используется для создания нового массива или объекта, содержащего элементы или свойства исходного массива или объекта.</li> <li>Распаковывает элементы массива или свойства объекта, позволяя передавать их в другие функции или объединять с другими массивами или объектами.</li> </ul> <p>Пример: <span>const numbers = [1, 2, 3]; const newArray = [...numbers, 4, 5]; // [1, 2, 3, 4, 5]</span></p> <p>Rest-оператор (...):</p> <ul> <li>Собирает оставшиеся аргументы функции в массив.</li> <li>Используется для объявления параметра функции, который будет содержать все оставшиеся аргументы, переданные при вызове функции.</li> </ul> <p>Пример:</p> <p>function sum(...numbers) { let total = 0; for (let number of numbers) { total += number; } return total; console.log(sum(1, 2, 3, 4, 5)); // 15</p> <p>function printNames(first, last, ...middle) { console.log('First name:', first); console.log('Last name:', last);   console.log('Middle names:', middle); } printNames('John', 'Doe', 'Smith', 'Johnson', 'Williams'); // First name: John  // Last name: Doe // Middle names: ['Smith', 'Johnson', 'Williams']</p> <p></p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Как определить наличие свойства в объекте?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>В JavaScript есть несколько способов определить наличие свойства в объекте.</p> <p>Оператор in: Можно использовать оператор in, чтобы проверить наличие свойства в объекте или его прототипе.</p> <p>const obj = { name: 'John', age: 30 }; console.log('name' in obj); // true console.log('city' in obj); // false</p> <p>Метод hasOwnProperty(): Метод hasOwnProperty() проверяет, содержит ли объект указанное свойство и не учитывает свойства в прототипе объекта.</p> <p>const obj = { name: 'John', age: 30 }; console.log(obj.hasOwnProperty('name')); // true console.log(obj.hasOwnProperty('city')); // false</p> <p>Сравнение со значением undefined: Можно сравнить значение свойства с undefined, чтобы определить его наличие.</p> <p>const obj = { name: 'John', age: 30 }; console.log(obj.name !== undefined); // true  console.log(obj.city !== undefined); // false</p> <p>Использование Object.keys(): Можно использовать метод Object.keys() для получения массива всех свойств объекта и затем проверить наличие свойства в этом массиве.</p> <p>const obj = { name: 'John', age: 30 }; console.log(Object.keys(obj).includes('name')); // true console.log(Object.keys(obj).includes('city')); // false</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "Чем отличается Map от WeakMap?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Map и WeakMap - это две разные структуры данных в JavaScript, которые предоставляют ассоциативное отображение ключей на значения.</p> <p>Вот основные отличия между Map и WeakMap:</p> <ol> <li><span>Сильные ссылки и сборка мусора:</span> В Map используются сильные ссылки на ключи, что означает, что если объект, используемый в качестве ключа, больше не используется, он не будет удален из памяти, пока есть ссылка на него. В WeakMap используются слабые ссылки на ключи, что означает, что если объект, используемый в качестве ключа, больше не имеет других ссылок, кроме ссылки из WeakMap, он может быть удален сборщиком мусора.</li> <li><span>Ключи:</span> В Map ключами могут быть любые значения, включая примитивы и объекты. В WeakMap ключами могут быть только объекты.</li> <li><span>Итерация:</span> Map поддерживает итерацию с помощью методов keys(), values() и entries(), которые возвращают итераторы для перебора ключей, значений и пар ключ-значение соответственно. WeakMap не поддерживает эти методы, поскольку слабые ссылки могут быть непредсказуемыми и не гарантируют порядок итерации.</li> <li><span>Размер:</span> Map имеет свойство size, которое возвращает количество элементов в Map. WeakMap не имеет свойства size, поскольку слабые ссылки не позволяют точно определить количество элементов.</li> <li><span>Методы:</span> Map предоставляет различные методы для работы с элементами, такие как set(), get(), has(), delete() и другие. WeakMap предоставляет только методы get(), set(), has() и delete().</li> <li>В целом, Map обычно используется для обычных случаев ассоциативного отображения, когда ключи и значения должны оставаться в памяти, пока есть ссылки на них. WeakMap полезен, когда вам нужно ассоциативное отображение с объектами в качестве ключей, и вы хотите, чтобы объекты могли быть автоматически удалены из WeakMap, когда больше нет ссылок на них.</li> </ol> <p>Еще можно почитать <a class='question__link' href='https://learn.javascript.ru/weakmap-weakset' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap' target='_blank' rel='noopener noreferrer'>здесь</a>.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 21,
    question: "Чем отличается Set от WeakSet?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Основное отличие между Set и WeakSet заключается в типе значений, которые они могут содержать, и в поведении при сборке мусора. Set может содержать любые значения и не удаляет их автоматически, а WeakSet может содержать только объекты и может быть автоматически очищен сборщиком мусора, если на объект больше нет ссылок.</p> <p>Еще можно почитать <a class='question__link' href='https://learn.javascript.ru/weakmap-weakset' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap' target='_blank' rel='noopener noreferrer'>здесь</a>.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "Как работает сборщик мусора в JS?",
    answer: {
      href: "https://habr.com/ru/articles/784548/",
      linkName: "habr.com",
      answer1:
        "<p>Сборщик мусора в JavaScript является встроенной функцией, которая автоматически освобождает память, занятую объектами, которые больше не используются в программе. Он следит за объектами, которые были созданы во время выполнения программы, и определяет, когда они больше не доступны для использования.</p> <p>Сборщик мусора в JS использует алгоритм под названием 'Mark and Sweep' (Пометка и Очистка). Вот как это работает:</p> <ul> <li>Пометка (Mark): Сборщик мусора начинает с корневых объектов, таких как глобальный объект (window в браузере) и все объекты, на которые есть ссылки из корневых объектов. Он помечает эти объекты как активные.</li> <li>Распространение (Propagation): Сборщик мусора рекурсивно проходит через все активные объекты и помечает объекты, на которые они ссылаются, как активные. Этот процесс продолжается до тех пор, пока все достижимые объекты не будут помечены.</li> <li>Очистка (Sweep): После завершения пометки и распространения, сборщик мусора проходит по всей памяти и освобождает память, занятую не помеченными объектами. Он удаляет эти объекты и восстанавливает память для будущего использования.</li> </ul> <p>Еще можно почитать <a class='question__link' href='https://learn.javascript.ru/garbage-collection' target='_blank' rel='noopener noreferrer'>здесь</a> и <a class='question__link' href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_management' target='_blank' rel='noopener noreferrer'>здесь</a>.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

/* Вопросы и ответы для собеседования на позицию frontend-разработчик. Часть 1 */
/* https://habr.com/ru/articles/785596/*/
/* не заполнено */
const questionsJSHabrPart2 = [
  {
    id: 1,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 21,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 26,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question: "",
    answer: {
      href: "https://habr.com/ru/articles/785596/",
      linkName: "habr.com",
      answer1: "",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

/* 35 вопросов с собеседования JavaScript-разработчика
 */
/* https://habr.com/ru/articles/578370/ */
/* разметка сделана */
const questionsJSHabr35 = [
  {
    id: 1,
    question:
      "В чем смысл оборачивания всего содержимого JavaScript-файла в функцию?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Этот шаблон называется <span>IIFE - Immediately Invoked Function Expression</span>  (немедленно вызываемое функциональное выражение). Этот подход позволяет:</p> <ul> <li>обеспечить коду собственный блок видимости, то-есть контекст выполнения,</li> <li>избежать загрязнения глобальной области видимости глобальными переменными,</li> <li>избежать неумышленного переопределения уже существующих переменных в глобальной области видимости</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 2,
    question:
      "В чем смысл и польза указания use strict в начале JavaScript-файла?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Команда use strict включает так называемый строгий режим. В этом режиме предупреждения становятся ошибками, что помогает в написании более чистого и безопасного кода, менее уязвимого к ошибкам в продакшене.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 3,
    question:
      "Что такое NaN? Какого типа это значение? Как можно узнать, равно ли значение переменной NaN?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>NaN расшифровывается как 'Not A Number', это 'falsey' (ложное) значение.</p> <p>Выражение typeof NaN возвращает тип Number.</p> <p>Проверить значение переменной на соответствие NaN можно, воспользовавшись встроенным методом isNaN() или используя оператор тройного равенства ===.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 4,
    question: "Что такое замыкание в JavaScript? Приведите пример.",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Замыкание в JavaScript - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем.</p> <p>В следующем примере мы определяем функцию makeCounter(), которая фактически является фабричной функцией. При вызове она возвращает дочернюю функцию, которая имеет доступ к лексическому окружению внешней функции, то-есть функции makeCounter(). Таким образом, возвращаемая функция запоминает переменную counter и в последующем изменяет ее значение.</p> <p>function makeCounter(initial = 0) { let counter = initial;   return function() { return counter += 1;}} const counterA = makeCounter(0); console.log(counterA()); // 1 console.log(counterA()); // 2 const counterB = makeCounter(100); console.log(counterB()); // 101 console.log(counterB()); // 102</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 5,
    question: "Как можно клонировать объект?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Можно использовать оператор остатка ....</p> <p>Можно использовать Object.assign(newObj, oldObj).</p> <p>Но эти подходы не позволяют выполнить глубокое клонирование. Поэтому, если нам нужно клонировать объект со вложенными объектами, мы можем использовать либо метод какой-либо библиотеки (привет, lodash), либо сделать это средствами встроенного объекта</p> <p>JSON. JSON.parse(JSON.stringify(objectToClone))</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 6,
    question: "Как можно добавить элемент в начало и в конец массива?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Чтобы добавить элемент в начало массива, можно использовать Array.prototype.unshift(). Для добавления элемента в конец массива подойдет Array.prototype.push().</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 7,
    question: "В чем разница между undefined и is not defined?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>undefined - это значение, присваемое объявленной, но не проинициализированной переменной. Мы получаем undefined, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку is not defined</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 8,
    question: "Как проверить, является ли объект массивом?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Для этого можно использовать встроенный метод Array.isArray().</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 9,
    question: "Что такое hoisting (поднятие) в JavaScript?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.</p> <p>Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.</p> <p>По этой причине, например, мы можем использовать до объявления функцию, объявленную через Function Declaration, но не можем ту, которая объявлена через Function Expression.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 10,
    question: "Что такое this?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>this указывает на объект области видимости во время выполнения. По умолчанию this указывает на глобальный объект. В браузере выражение this === window будет истинно.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 11,
    question: "Как работает прототипное наследование?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Если отвечать кратко, в JavaScript все является объектами. Эти объекты связаны цепочками прототипов, по которым им передаются методы и свойства. При обращении к свойству или методу объекта сначала происходит поиск этого свойства у самого объекта. В случае неудачи поиск перенаправляется в его прототип, затем в прототип прототипа и так далее, пока искомое свойство не будет найдено, либо пока не закончится цепочка прототипов.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 12,
    question:
      "Объясните, почему запись function foo(){}() вызывает ошибку и не работает, как IIFE?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Здесь дело в том, что круглые скобки вызова функции добавлены сразу после Function Declaration. Однако, они могут следовать только за выражением (expression). Поэтому мы должны либо прибегнуть к варианту с Function Expression, либо обернуть Function Declaration в скобки, тем самым превратив его в выражение.</p> <p>const foo = function(){}() // либо (function foo(){})() // либо со стрелочной функцией (() => {})()</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 13,
    question: "В чем разница между null, undefined и undeclared?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>null - это в прямом смысле 'ничего'. Можно использовать это значение в качестве плейсхолдера.</p> <p>undefined - это значение для случая 'объявлено, но не инициализировано'.</p> <p>undeclared - это ошибка, возникающая в случае обращении к необъявленной переменной.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 14,
    question:
      "В чем разница между Array.prototype.forEach и Array.prototype.map?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Array.prototype.forEach - это инструмент обхода цикла процедурно, а Array.prototype.map - функционально.</p> <p>.forEach просто проходится по массиву с выполнением переданного обратного вызова на каждой итерации, а .map создает и возвращает новый массив на основе исходного, выкладывая по кирпичику на каждой итерации.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 15,
    question: "В каких случаях используются анонимные функции?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Анонимные функции чаще всего используются в качестве функций обратных вызовов. Также, каждая стрелочная функция является анонимной</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 16,
    question:
      "Объясните разницу между const person = Person() и const person = new Person() при function Person(){}",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Если функция Person() не возвращает явным образом создаваемый экземпляр, то вариант const person = Person() присвоит константе person значение undefined, поскольку именно таков результат void функции.</p> <p>Если функция Person явным образом возвращает экземпляр, он станет значением константы person при const person = Person().</p> <p>Однако, вариант с использование оператора new 'выигрывает', поскольку он устанавливает корректную связь объекта person с цепочкой прототипов Person, в то время как выражение const person = Person() просто присваивает константе результат вызова функции.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 17,
    question:
      "В чем разница между Function.prototype.call и Function.prototype.apply?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Оба метода вызывают исходный метод с подмененным контекстом, но .call принимает параметры через запятую, а .apply - массивом.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 18,
    question: "Как работает Function.prototype.bind?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Данный метод возвращает функцию, по отношению к которой он вызывается, но с подмененным контекстом.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 19,
    question: "Что вы знаете об AJAX?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>AJAX = Asynchronous Javascript And XML. Это подход к асинхронному (неблокирующему) обмену данными с сервером.</p> <p>Изначально для решения подобной задачи использовался объект XMLHttpRequest , сейчас же более актуален дружелюбный к обещаниям (Promise) fetch API.</p>  ",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 20,
    question: "В чем разница между атрибутами и свойствами?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Атрибут - это HTML-термин, в то время как свойство - термин из JavaScript. Иными словами, если речь идет о значении в HTML-разметке, мы говорим об атрибуте. Однако, если имеется в виду свойство объекта, к которому мы получили доступ средствами JavaScript - вернее называть это свойством.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 21,
    question: "В чем разница между == и ===?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Оператор двойного равенства производит приведение типов, оператор строгого равенства - нет.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 22,
    question:
      "Почему лучше оставлять глобальную область видимости 'как есть' и не трогать ее?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>По той причине, что свойства глобальной области видимости может изменить любой JavaScript-код, имеющий к ней доступ. Также, это грозит конфликтами имен.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 23,
    question: "Что такое SPA и как сделать его SEO-friendly?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Single Page Application - это реализация веб-приложения таким образом, чтобы при первой загрузке пользователь получал все ресурсы, необходимые для того, чтобы избавиться от загрузки страницы с нуля при совершении интерактивных действий с интерфейсом.</p> <p>Основную роль в SPA играет JavaScript, реализующий механизмы динамического обновления данных без перезагрузки страницы.</p> <p>Для того, чтобы сделать SPA SEO-friendly, можно обратиться к таким решениям, как предварительный рендеринг или серверный рендеринг.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 24,
    question:
      "Какие преимущества и недостатки у использования Promise API вместо обратных вызовов?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Обещания избавляют разработчиков от ада обратных вызовов, но это не единственное их достоинство.</p> <p>Важно также отметить, что пользуясь обратными вызовами, мы зачастую были вынуждены 'верить' стороннему коду. А вызовет ли он наш коллбэк? А вызовет ли он его корректное количество раз? А не вызовет ли он его слишком рано или слишком поздно?</p> <p>Представьте, что функция, снимающая деньги со счета пользователя, передается коллбэком в сторонний (в той или иной степени) код. Что будет, если он вследствие внесенных со стороны изменений начнет вести себя некорректно и, скажем, начнет вызывать эту функцию пять раз вместо одного?</p> <p>Используя обещания, мы сами властны над нашим кодом. Мы сначала дожидаемся результата вызова сторонней функции, возвращающей обещание, а потом передаем управление необходимому блоку кода. Обещание может быть разрешено один раз и с тех пор оно неизменно, так что надежность нашего кода резко возрастает.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 25,
    question: "Какие инструменты вы используете при отладке?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>При первой встрече с проблемой я, не спеша усложнять себе жизнь, обращаюсь к console.log. Если это не помогает, вызываю тяжелую артиллерию в виде браузерного отладчика.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 26,
    question:
      "Какие конструкции языка вы используете для обхода массивов и объектов?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>В случае с массивами, это чаще всего forEach и map. Реже возникает необходимость в for, for in, for of, reduce, filter и подобных.</p> <p>А чтобы обойти объект, понадобится немного изобретательности. Один из вариантов - получить ключи с помощью Object.keys, по которым впоследствии пройти с помощью forEach. Либо же можно воспользоваться Object.values, Object.entries, Object.keys.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 27,
    question: "Объясните разницу между изменяемыми и неизменяемыми значениями",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Значения примитивных типов (например, строка или число) не могут быть изменены после того, как попали в память.</p> <p>Значения объектных типов (объекты, массивы) могут изменяться в ходе работы программы.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 28,
    question: "Объясните разницу между синхронными и асинхронными функциями",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>JavaScript - это однопоточный язык, то-есть функции выполняются в синхронном порядке. Приложение блокируется на время выполнения каждой конкретной функции. Так происходит по той причине, что JavaScript имеет только один стек вызовов.</p> <p>С другой стороны, есть асинхронный способ выполнения функций, когда мы не блокируем весь интерфейс благодаря тому, что не дожидаемся выполнения функции, а подписываемся на событие с передачей обратного вызова. Ну, или мы можем иметь дело с обещанием или с прочими внешними API вроде setTimeout.</p> <p>В таком случае браузер помещает обработчик события в очередь задач, а когда наступает время его вызвать, он перемещает его в стек вызовов.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 29,
    question:
      "Что такое цикл событий? В чем разница между стеком вызовов и очередью задач?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Стек вызовов - это структура данных (первым вошел, последним вышел), используемая для отслеживания порядка выполнения функций в текущем контексте (области видимости).</p> <p>Очередь задач - это структура данных (первым вошел, первым вышел), используемая для отслеживания выполнения асинхронных функций, готовых оказаться в стеке вызовов.</p> <p>Цикл событий - это механизм, на каждом тике выполняющий функции из стека вызовов и, если он оказывается пустым, перемещающий задачи из очереди задач в стек вызовов для выполнения.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 30,
    question: "В чем разница между let, const и var?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>var </p> <ul> <li>поднимается в начало области видимости функции при компиляции;</li> <li>объявляет переменную, которая может быть перезаписана;</li> <li>объявляет переменную, которая может быть переопределена;</li> </ul> <p>let</p> <ul> <li>поднимается в начало области видимости блока при компиляции;</li> <li>объявляет переменную, которая может быть перезаписана;</li> <li>объявляет переменную, которая не может быть переопределена;</li> </ul> <p>const</p> <ul> <li>поднимается в начало области видимости блока при компиляции;</li> <li>объявляет переменную, которая не может быть перезаписана или переопределена</li> </ul>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 31,
    question: "В чем разница между ES6 class и ES5 function constructor?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Классы, добавленные в стандарте EcmaScript 6, всего лишь синтаксический сахар поверх всем известных прототипов.</p> <p> В работе эти подходы отличаются уровнем абстракции, который ожидаемо выше у классов - разработчику не приходится напрямую работать с прототипами.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 32,
    question: "Что такое функция высшего порядка?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Функция, принимающая функцию обратного вызова в качестве аргумента.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 33,
    question: "Что такое DOM?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>DOM - Document Object Model (объектная модель документа). Другими словами, это дерево всех узлов страницы, которые распознал браузер в процессе обработки HTML-разметки.</p> <p>DOM - это интерфейс, позволяющий JavaScript-коду взаимодействовать с шаблоном.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 34,
    question:
      "В чем разница между областью видимости функции и блочной областью видимости?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>И то, и то является полноценной областью видимости. Различие наблюдается при использовании ключевого слова var, которое ограничивается только областью видимости функции, но не блочной областью видимости.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
  {
    id: 35,
    question:
      "Что произойдет в результате выражения var foo = 10 + '20' и почему?",
    answer: {
      href: "https://habr.com/ru/articles/578370/",
      linkName: "35 вопросов с собеседования JavaScript-разработчика",
      answer1:
        "<p>Переменная foo примет значение '1020'.</p> <p>В JavaScript это поведение называется приведением типов. Если хотя бы один из операндов является строкой, второй также будет преобразован в строку.</p>",
      image1: "",
      href2: "",
      linkName2: "",
      answer2: "",
      image2: "",
    },
  },
];

let questionJavaScript = questionsJSProglibPart1.concat(
  ...questionsJSProglibPart1
);

function extractQuestionsKey(questions) {
  return questions.map((question) => {
    return {
      id: question.id,
      question: question.question,
      answer: question.answer.href,
    };
  });
}

let questionsHabr70 = extractQuestionsKey(questionsJSHabr);
let questionsProglibPart1 = extractQuestionsKey(questionsJSProglibPart1);
let questionsProglibPart2 = extractQuestionsKey(questionsJSProglibPart2);
let questionsProglib10 = extractQuestionsKey(questionsJSProglib10);
let questionsTproger30 = extractQuestionsKey(questionsJSTproger30);
let questionsHabrPart1 = extractQuestionsKey(questionsJSHabrPart1);
let questionsHabrPart2 = extractQuestionsKey(questionsJSHabrPart2);
let questionsHabr35 = extractQuestionsKey(questionsJSHabr35);

const commonList = [
  ...questionsHabr70,
  ...questionsProglibPart1,
  ...questionsProglibPart2,
  ...questionsProglib10,
  ...questionsTproger30,
  ...questionsHabrPart1,
  // ...questionsHabrPart2,
  ...questionsHabr35,
];

export { questionsJSHabr };
export { questionsJSProglibPart1 };
export { questionsJSProglibPart2 };
export { questionsJSProglib10 };
export { questionsJSTproger30 };
export { questionsJSHabrPart1 };
export { questionsJSHabrPart2 }; //не заполнено
export { questionsJSHabr35 };
export { questionJavaScript };
export { commonList };
